/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmdt_charts"] = self["webpackChunkmdt_charts"] || []).push([["src_engine_engine_ts"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/main.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/main.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".main-wrapper  {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n\\r\\n.form {\\r\\n    display: flex;\\r\\n    flex-wrap: wrap;\\r\\n}\\r\\n.controls-block  {\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    border: 1px solid black;\\r\\n    padding: 0 .2rem;\\r\\n    box-sizing: border-box;\\r\\n    margin: 1rem 0;\\r\\n}\\r\\n.form-group {\\r\\n    margin: 10px;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n}\\r\\n.controls-group {\\r\\n    display: flex;\\r\\n}\\r\\n.controls-section {\\r\\n    margin-top: 1rem;\\r\\n}\\r\\nlabel {\\r\\n    font-size: 12px;\\r\\n}\\r\\n\\r\\n.wrapper {\\r\\n    margin: 0 auto;\\r\\n    position: relative;\\r\\n}\\r\\nh3.title {\\r\\n    font-size: 18px;\\r\\n    font-weight: 500;\\r\\n}\\r\\n.bar, .area, .donut {\\r\\n    stroke: none;\\r\\n}\\r\\n.line {\\r\\n    fill: none;\\r\\n    stroke-width: 4;\\r\\n}\\r\\n.outline {\\r\\n    outline: 1px solid black;\\r\\n}\\r\\n.data-label {\\r\\n    font-family: \\\"Roboto\\\" sans-serif;\\r\\n    font-style: normal;\\r\\n    font-weight: 300;\\r\\n    font-size: 12px;\\r\\n    line-height: 140.62%;\\r\\n    color: #444444;\\r\\n}\\r\\n\\r\\n.legend-item-inline {\\r\\n    white-space: nowrap;\\r\\n}\\r\\n.legend-item-inline:not(:first-of-type) {\\r\\n    margin-left: 20px;\\r\\n}\\r\\n.legend-item-row {\\r\\n    display: flex;\\r\\n}\\r\\n.legend-item-row > span {\\r\\n    display: block;\\r\\n}\\r\\n.mt-15 {\\r\\n    margin-top: 15px;\\r\\n}\\r\\n.mt-10 {\\r\\n    margin-top: 10px;\\r\\n}\\r\\n\\r\\n.legend-label {\\r\\n    font-size: 12px;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    font-weight: 300;\\r\\n    color: #444444;\\r\\n    width: calc(100% - 19px);\\r\\n    overflow: hidden;\\r\\n}\\r\\n.legend-label-nowrap {\\r\\n    white-space: nowrap;\\r\\n    text-overflow: ellipsis;\\r\\n}\\r\\n.legend-circle {\\r\\n    display: inline-block;\\r\\n    width: 11px;\\r\\n    height: 11px;\\r\\n    border-radius: 50%;\\r\\n    margin-right: 8px;\\r\\n}\\r\\n\\r\\n.tooltip-circle {\\r\\n    display: inline-block;\\r\\n    width: 11px;\\r\\n    height: 11px;\\r\\n    border-radius: 50%;\\r\\n    margin-right: 13px;\\r\\n}\\r\\n.tooltip-block {\\r\\n    pointer-events: none;\\r\\n    z-index: 100;\\r\\n    filter: drop-shadow(0px 4px 10px rgba(0, 0, 0, 0.1));\\r\\n}\\r\\n.tooltip-content {\\r\\n    position: relative;\\r\\n    pointer-events: none;\\r\\n    font-size: 14px;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    line-height: 1;\\r\\n    font-weight: bold;\\r\\n    padding: 15px 20px 15px 15px;\\r\\n    background: white;\\r\\n    color: black;\\r\\n    z-index: 102;\\r\\n    max-width: 500px;\\r\\n}\\r\\n.tooltip-arrow {\\r\\n    position: absolute;\\r\\n    z-index: 101;\\r\\n    background-color: white;\\r\\n    transform: rotate(45deg);\\r\\n}\\r\\n.tooltip-group {\\r\\n    display: flex;\\r\\n}\\r\\n.tooltip-text-item {\\r\\n    font-family: \\\"Roboto\\\" sans-serif;\\r\\n    font-weight: 700;\\r\\n    font-style: normal;\\r\\n    font-size: 14px;\\r\\n    white-space: nowrap;\\r\\n    /* line-height: 19.69px; */\\r\\n}\\r\\n.tooltip-group:not(:first-of-type) {\\r\\n    margin-top: 8px;\\r\\n}\\r\\n.tooltip-line {\\r\\n    stroke: #b6b6b6;\\r\\n    stroke-dasharray: 3;\\r\\n    stroke-width: 1px;\\r\\n}\\r\\n\\r\\n.aggregator-value, .aggregator-name {\\r\\n    color: #000000;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    font-weight: bold;\\r\\n}\\r\\n.aggregator-value {\\r\\n    margin-top: 20px;\\r\\n}\\r\\n\\r\\n.grid-line {\\r\\n    stroke: #D2D2D2;\\r\\n    stroke-dasharray: 3;\\r\\n}\\r\\n\\r\\n.axis .domain {\\r\\n    stroke: #D2D2D2;\\r\\n}\\r\\n.axis .tick line:first-of-type {\\r\\n    stroke: #D2D2D2;\\r\\n}\\r\\n\\r\\n.record-overflow-alert {\\r\\n    background-color: #FFFFFF;;\\r\\n    padding: 5px 10px 5px;\\r\\n    border: 1px solid #0F6698;\\r\\n    box-sizing: border-box;\\r\\n    border-radius: 100px;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    font-style: normal;\\r\\n    font-weight: 500;\\r\\n    font-size: 10px;\\r\\n    line-height: 140.62%;\\r\\n    color: #0F6698;\\r\\n}\\r\\n.record-overflow-alert .btn-close {\\r\\n    border: none;\\r\\n    background-color: transparent;\\r\\n    cursor: pointer;\\r\\n    font-size: 1.3rem;\\r\\n}\\r\\n\\r\\n.chart-block {\\r\\n    stroke-width: 1px !important;\\r\\n}\\r\\n\\r\\n.embedded-label {\\r\\n    color: #444444;\\r\\n    font-family: \\\"Roboto\\\", sans-serif;\\r\\n    font-style: normal;\\r\\n    font-weight: 500;\\r\\n    font-size: 12px;\\r\\n    line-height: 140.62%;\\r\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://mdt-charts/./src/style/main.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./src/style/main.css":
/*!****************************!*\
  !*** ./src/style/main.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./main.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style/main.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack://mdt-charts/./src/style/main.css?");

/***/ }),

/***/ "./src/engine/block/block.ts":
/*!***********************************!*\
  !*** ./src/engine/block/block.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Block = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/engine/helper.ts\");\r\nvar blockHelper_1 = __webpack_require__(/*! ./blockHelper */ \"./src/engine/block/blockHelper.ts\");\r\nvar Block = /** @class */ (function () {\r\n    function Block(cssClass, parentElement) {\r\n        this.chartBlockClass = 'chart-block';\r\n        this.wrapperCssClasses = helper_1.Helper.getCssClassesArray(cssClass);\r\n        this.svgCssClasses = helper_1.Helper.getCssClassesArray(cssClass);\r\n        this.wrapperCssClasses = blockHelper_1.BlockHelper.getFormattedCssClassesForWrapper(this.wrapperCssClasses);\r\n        this.parentElement = parentElement;\r\n        this.parentElementSelection = d3.select(parentElement);\r\n    }\r\n    Block.prototype.renderSvg = function (blockSize) {\r\n        this.getWrapper()\r\n            .append('svg')\r\n            .attr('width', blockSize.width)\r\n            .attr('height', blockSize.height)\r\n            .attr('class', this.svgCssClasses.join(' '));\r\n    };\r\n    Block.prototype.renderWrapper = function (blockSize) {\r\n        this.wrapper = this.parentElementSelection\r\n            .append('div')\r\n            .attr('class', this.wrapperCssClasses.join(' '))\r\n            .style('width', blockSize.width + 'px')\r\n            .style('height', blockSize.height + 'px')\r\n            .style('position', 'relative');\r\n    };\r\n    Block.prototype.renderChartBlock = function () {\r\n        this.getSvg()\r\n            .append('g')\r\n            .attr('class', this.chartBlockClass);\r\n    };\r\n    Block.prototype.getSvg = function () {\r\n        return this.getWrapper().select('svg');\r\n    };\r\n    Block.prototype.getWrapper = function () {\r\n        return this.wrapper;\r\n    };\r\n    Block.prototype.getChartBlock = function () {\r\n        return this.getSvg()\r\n            .select(\".\" + this.chartBlockClass);\r\n    };\r\n    Block.prototype.renderClipPath = function (margin, blockSize) {\r\n        var attributes = blockHelper_1.BlockHelper.getChartBlockAttributes(blockSize, margin);\r\n        this.getSvg()\r\n            .append('defs')\r\n            .append('clipPath')\r\n            .attr('id', \"chart-block-clippath-\" + this.svgCssClasses.join('-'))\r\n            .append('rect')\r\n            .attr('x', attributes.x)\r\n            .attr('y', attributes.y)\r\n            .attr('width', attributes.width)\r\n            .attr('height', attributes.height);\r\n    };\r\n    Block.prototype.getClipPathId = function () {\r\n        return \"#chart-block-clippath-\" + this.svgCssClasses.join('-');\r\n    };\r\n    Block.prototype.getSvgCssClasses = function () {\r\n        return this.svgCssClasses;\r\n    };\r\n    return Block;\r\n}());\r\nexports.Block = Block;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/block/block.ts?");

/***/ }),

/***/ "./src/engine/block/blockHelper.ts":
/*!*****************************************!*\
  !*** ./src/engine/block/blockHelper.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BlockHelper = void 0;\r\nvar valueFormatter_1 = __webpack_require__(/*! ../valueFormatter */ \"./src/engine/valueFormatter.ts\");\r\nvar BlockHelper = /** @class */ (function () {\r\n    function BlockHelper() {\r\n    }\r\n    BlockHelper.getChartBlockAttributes = function (blockSize, margin) {\r\n        var outSize = 5.5;\r\n        return {\r\n            x: margin.left - outSize,\r\n            y: margin.top - outSize,\r\n            width: valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.width - margin.left - margin.right) + outSize * 2,\r\n            height: valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.height - margin.top - margin.bottom) + outSize * 2\r\n        };\r\n    };\r\n    BlockHelper.getFormattedCssClassesForWrapper = function (cssClasses) {\r\n        var wrapperClasses = [];\r\n        cssClasses.forEach(function (cssClass) {\r\n            wrapperClasses.push(cssClass + '-wrapper');\r\n        });\r\n        return wrapperClasses;\r\n    };\r\n    return BlockHelper;\r\n}());\r\nexports.BlockHelper = BlockHelper;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/block/blockHelper.ts?");

/***/ }),

/***/ "./src/engine/chartRenderer.ts":
/*!*************************************!*\
  !*** ./src/engine/chartRenderer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChartRenderer = void 0;\r\nvar area_1 = __webpack_require__(/*! ./twoDimensionalNotation/area/area */ \"./src/engine/twoDimensionalNotation/area/area.ts\");\r\nvar axis_1 = __webpack_require__(/*! ./features/axis/axis */ \"./src/engine/features/axis/axis.ts\");\r\nvar bar_1 = __webpack_require__(/*! ./twoDimensionalNotation/bar/bar */ \"./src/engine/twoDimensionalNotation/bar/bar.ts\");\r\nvar donut_1 = __webpack_require__(/*! ./polarNotation/donut */ \"./src/engine/polarNotation/donut.ts\");\r\nvar gridLine_1 = __webpack_require__(/*! ./features/gridLine/gridLine */ \"./src/engine/features/gridLine/gridLine.ts\");\r\nvar legend_1 = __webpack_require__(/*! ./features/legend/legend */ \"./src/engine/features/legend/legend.ts\");\r\nvar line_1 = __webpack_require__(/*! ./twoDimensionalNotation/line/line */ \"./src/engine/twoDimensionalNotation/line/line.ts\");\r\nvar scale_1 = __webpack_require__(/*! ./features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar tooltip_1 = __webpack_require__(/*! ./features/tolltip/tooltip */ \"./src/engine/features/tolltip/tooltip.ts\");\r\nvar recordOverflowAlert_1 = __webpack_require__(/*! ./features/recordOverflowAlert/recordOverflowAlert */ \"./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts\");\r\nvar gantt_1 = __webpack_require__(/*! ./intervalNotation/gantt */ \"./src/engine/intervalNotation/gantt.ts\");\r\nvar ChartRenderer = /** @class */ (function () {\r\n    function ChartRenderer() {\r\n    }\r\n    ChartRenderer.render2D = function (block, model, data) {\r\n        var options = model.options;\r\n        var scales = scale_1.Scale.getScales(options.scale.scaleKey, options.scale.scaleValue, model.chartSettings.bar);\r\n        block.renderSvg(model.blockCanvas.size);\r\n        axis_1.Axis.render(block, scales, options.scale, options.axis, model.chartBlock.margin, model.blockCanvas.size);\r\n        gridLine_1.GridLine.render(block, options.additionalElements.gridLine.flag, options.axis.keyAxis, options.axis.valueAxis, model.blockCanvas.size, model.chartBlock.margin, options.scale.scaleKey);\r\n        this.render2DCharts(block, options.charts, scales, data, model.chartBlock.margin, options.axis.keyAxis.orient, model.chartSettings.bar, model.blockCanvas.size, options.isSegmented);\r\n        legend_1.Legend.render(block, data, options, model.legendBlock, model.blockCanvas.size);\r\n        tooltip_1.Tooltip.renderTooltips(block, model, data);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0)\r\n            recordOverflowAlert_1.RecordOverflowAlert.render(block, model.dataSettings.scope.hidedRecordsAmount, 'top', options.orient);\r\n    };\r\n    ChartRenderer.renderPolar = function (block, model, data) {\r\n        var options = model.options;\r\n        block.renderSvg(model.blockCanvas.size);\r\n        this.renderPolarCharts(block, options.charts, data, model.chartBlock.margin, model.blockCanvas.size, model.chartSettings.donut);\r\n        legend_1.Legend.render(block, data, options, model.legendBlock, model.blockCanvas.size);\r\n        tooltip_1.Tooltip.renderTooltips(block, model, data);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0 && model.options.legend.position !== 'off')\r\n            recordOverflowAlert_1.RecordOverflowAlert.render(block, model.dataSettings.scope.hidedRecordsAmount, model.options.legend.position);\r\n    };\r\n    ChartRenderer.renderInterval = function (block, model, data) {\r\n        var options = model.options;\r\n        block.renderSvg(model.blockCanvas.size);\r\n        var scales = scale_1.Scale.getScales(options.scale.scaleKey, options.scale.scaleValue, model.chartSettings.bar);\r\n        axis_1.Axis.render(block, scales, options.scale, options.axis, model.chartBlock.margin, model.blockCanvas.size);\r\n        gridLine_1.GridLine.render(block, options.additionalElements.gridLine.flag, options.axis.keyAxis, options.axis.valueAxis, model.blockCanvas.size, model.chartBlock.margin, options.scale.scaleKey);\r\n        this.renderIntervalCharts(block, options.charts, scales, data, model.chartBlock.margin, options.axis.keyAxis.orient, model.chartSettings);\r\n        legend_1.Legend.render(block, data, options, model.legendBlock, model.blockCanvas.size);\r\n        tooltip_1.Tooltip.renderTooltips(block, model, data);\r\n        if (model.dataSettings.scope.hidedRecordsAmount !== 0)\r\n            recordOverflowAlert_1.RecordOverflowAlert.render(block, model.dataSettings.scope.hidedRecordsAmount, 'top', options.orient);\r\n    };\r\n    ChartRenderer.render2DCharts = function (block, charts, scales, data, margin, keyAxisOrient, barSettings, blockSize, isSegmented) {\r\n        block.renderClipPath(margin, blockSize);\r\n        block.renderChartBlock();\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'bar')\r\n                bar_1.Bar.render(block, scales, data[chart.data.dataSource], margin, keyAxisOrient, chart, blockSize, barSettings, isSegmented);\r\n            else if (chart.type === 'line')\r\n                line_1.Line.render(block, scales, data[chart.data.dataSource], margin, keyAxisOrient, chart, blockSize, isSegmented);\r\n            else if (chart.type === 'area')\r\n                area_1.Area.render(block, scales, data[chart.data.dataSource], margin, keyAxisOrient, chart, blockSize, isSegmented);\r\n        });\r\n    };\r\n    ChartRenderer.renderPolarCharts = function (block, charts, data, margin, blockSize, donutSettings) {\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'donut')\r\n                donut_1.Donut.render(block, data[chart.data.dataSource], margin, chart, blockSize, donutSettings);\r\n        });\r\n    };\r\n    ChartRenderer.renderIntervalCharts = function (block, charts, scales, data, margin, keyAxisOrient, chartSettings) {\r\n        block.renderChartBlock();\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'gantt')\r\n                gantt_1.Gantt.render(block, data[chart.data.dataSource], scales, margin, keyAxisOrient, chart, chartSettings.bar);\r\n        });\r\n    };\r\n    ChartRenderer.updateByValueAxis = function (block, model, data) {\r\n        var options = model.options;\r\n        var scales = scale_1.Scale.getScales(options.scale.scaleKey, options.scale.scaleValue, model.chartSettings.bar);\r\n        axis_1.Axis.updateValueAxisDomain(block, scales.scaleValue, options.scale.scaleValue, options.axis.valueAxis);\r\n        gridLine_1.GridLine.rerender(block, options.additionalElements.gridLine.flag, options.axis.keyAxis, options.axis.valueAxis, model.blockCanvas.size, model.chartBlock.margin, options.scale.scaleKey);\r\n        this.updateChartsByValueAxis(block, options.charts, scales, data, model.chartBlock.margin, options.axis.keyAxis.orient, model.blockCanvas.size, options.isSegmented);\r\n    };\r\n    ChartRenderer.updateChartsByValueAxis = function (block, charts, scales, data, margin, keyAxisOrient, blockSize, isSegmented) {\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'bar') {\r\n                bar_1.Bar.updateBarChartByValueAxis(block, scales, margin, keyAxisOrient, chart, blockSize, isSegmented);\r\n            }\r\n            else if (chart.type === 'line') {\r\n                line_1.Line.updateLineChartByValueAxis(block, scales, data[chart.data.dataSource], margin, keyAxisOrient, chart);\r\n            }\r\n            else if (chart.type === 'area') {\r\n                area_1.Area.updateAreaChartByValueAxis(block, scales, data[chart.data.dataSource], margin, chart, keyAxisOrient, blockSize, isSegmented);\r\n            }\r\n        });\r\n    };\r\n    return ChartRenderer;\r\n}());\r\nexports.ChartRenderer = ChartRenderer;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/chartRenderer.ts?");

/***/ }),

/***/ "./src/engine/engine.ts":
/*!******************************!*\
  !*** ./src/engine/engine.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nvar block_1 = __webpack_require__(/*! ./block/block */ \"./src/engine/block/block.ts\");\r\nvar valueFormatter_1 = __webpack_require__(/*! ./valueFormatter */ \"./src/engine/valueFormatter.ts\");\r\nvar chartRenderer_1 = __webpack_require__(/*! ./chartRenderer */ \"./src/engine/chartRenderer.ts\");\r\nvar Engine = /** @class */ (function () {\r\n    function Engine() {\r\n    }\r\n    Engine.prototype.render = function (model, data, parentElement) {\r\n        valueFormatter_1.ValueFormatter.setFormatFunction(model.dataFormat.formatters);\r\n        this.block = new block_1.Block(model.blockCanvas.cssClass, parentElement);\r\n        this.block.renderWrapper(model.blockCanvas.size);\r\n        if (model.options.type === '2d')\r\n            chartRenderer_1.ChartRenderer.render2D(this.block, model, data);\r\n        else if (model.options.type === 'polar')\r\n            chartRenderer_1.ChartRenderer.renderPolar(this.block, model, data);\r\n        else if (model.options.type === 'interval')\r\n            chartRenderer_1.ChartRenderer.renderInterval(this.block, model, data);\r\n    };\r\n    Engine.prototype.updateFullBlock = function (model, data) {\r\n        this.clearBlock();\r\n        this.render(model, data, this.block.parentElement);\r\n    };\r\n    Engine.prototype.updateValueAxis = function (model, data) {\r\n        chartRenderer_1.ChartRenderer.updateByValueAxis(this.block, model, data);\r\n    };\r\n    Engine.prototype.clearBlock = function () {\r\n        this.block.getWrapper().remove();\r\n    };\r\n    return Engine;\r\n}());\r\nexports.default = Engine;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/engine.ts?");

/***/ }),

/***/ "./src/engine/features/axis/axis.ts":
/*!******************************************!*\
  !*** ./src/engine/features/axis/axis.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Axis = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar marginModel_1 = __webpack_require__(/*! ../../../model/marginModel */ \"./src/model/marginModel.ts\");\r\nvar MINIMAL_STEP_SIZE = 40;\r\nvar Axis = /** @class */ (function () {\r\n    function Axis() {\r\n    }\r\n    Axis.render = function (block, scales, scaleModel, axisModel, margin, blockSize) {\r\n        this.renderAxis(block, scales.scaleValue, scaleModel.scaleValue, axisModel.valueAxis, margin, blockSize);\r\n        this.renderAxis(block, scales.scaleKey, scaleModel.scaleKey, axisModel.keyAxis, margin, blockSize);\r\n    };\r\n    Axis.updateValueAxisDomain = function (block, scaleValue, scaleOptions, axisOptions) {\r\n        var axis = this.getAxisByOrient(axisOptions.orient, scaleValue);\r\n        this.setAxisFormat(scaleValue, scaleOptions, axis);\r\n        if (!axisOptions.ticks.flag)\r\n            this.removeTicks(axis);\r\n        this.setAxisLabelPaddingByOrient(axis, axisOptions);\r\n        block.getSvg()\r\n            .select(\"g.\" + axisOptions.cssClass)\r\n            .transition()\r\n            .duration(1000)\r\n            .call(axis.bind(this));\r\n    };\r\n    Axis.renderAxis = function (block, scale, scaleOptions, axisOptions, margin, blockSize) {\r\n        var axis = this.getAxisByOrient(axisOptions.orient, scale);\r\n        this.setAxisFormat(scale, scaleOptions, axis);\r\n        if (!axisOptions.ticks.flag)\r\n            this.removeTicks(axis);\r\n        if (axisOptions.type === 'value')\r\n            this.setStepSize(blockSize, margin, axis, axisOptions, scaleOptions);\r\n        this.setAxisLabelPaddingByOrient(axis, axisOptions);\r\n        var axisElement = block.getSvg()\r\n            .append('g')\r\n            .attr('transform', \"translate(\" + axisOptions.translate.translateX + \", \" + axisOptions.translate.translateY + \")\")\r\n            .attr('class', \"axis \" + axisOptions.cssClass + \" data-label\")\r\n            .call(axis);\r\n        if (axisOptions.labels.visible) {\r\n            if (axisOptions.orient === 'bottom' && axisOptions.type === 'key' && axisOptions.labels.positition === 'rotated')\r\n                this.rotateLabels(axisElement);\r\n            if (axisOptions.orient === 'left' && axisOptions.type === 'key' && scale_1.Scale.getScaleStep(scale) >= 38) {\r\n                axisElement.selectAll('.tick text').call(this.wrap, axisOptions.labels.maxSize);\r\n            }\r\n            else {\r\n                this.cropLabels(block, scale, scaleOptions, axisOptions, blockSize);\r\n            }\r\n            if (axisOptions.type === 'key' && axisOptions.orient === 'left') {\r\n                this.alignLabels(axisElement, 'start', axisOptions.labels.maxSize);\r\n            }\r\n        }\r\n        else {\r\n            this.hideLabels(axisElement);\r\n        }\r\n    };\r\n    Axis.setStepSize = function (blockSize, margin, axis, axisOptions, scale) {\r\n        var axisLength = blockSize.width - margin.left - margin.right;\r\n        if (axisOptions.orient === 'left' || axisOptions.orient === 'right') {\r\n            axisLength = blockSize.height - margin.top - margin.bottom;\r\n        }\r\n        if (axisLength / 10 < MINIMAL_STEP_SIZE) {\r\n            if (Math.floor(axisLength / MINIMAL_STEP_SIZE) > 2)\r\n                axis.ticks(Math.floor(axisLength / MINIMAL_STEP_SIZE));\r\n            else\r\n                axis.tickValues([d3.min(scale.domain), d3.max(scale.domain)]);\r\n        }\r\n    };\r\n    Axis.alignLabels = function (axisElement, anchor, maxLabelSize) {\r\n        var axisTextBlocks = axisElement.selectAll('text');\r\n        axisTextBlocks.attr('text-anchor', anchor);\r\n        axisTextBlocks.attr('x', -(maxLabelSize + marginModel_1.AXIS_VERTICAL_LABEL_PADDING));\r\n        var spans = axisElement.selectAll('tspan');\r\n        spans.attr('text-anchor', anchor);\r\n        spans.attr('x', -(maxLabelSize + marginModel_1.AXIS_VERTICAL_LABEL_PADDING));\r\n    };\r\n    Axis.setAxisLabelPaddingByOrient = function (axis, axisOptions) {\r\n        var axisLabelPadding = marginModel_1.AXIS_HORIZONTAL_LABEL_PADDING;\r\n        if (axisOptions.orient === 'left' || axisOptions.orient === 'right')\r\n            axisLabelPadding = marginModel_1.AXIS_VERTICAL_LABEL_PADDING;\r\n        axis.tickPadding(axisLabelPadding);\r\n    };\r\n    Axis.rotateLabels = function (axisElement) {\r\n        var labelBlocks = axisElement.selectAll('text');\r\n        labelBlocks.attr('text-anchor', 'end');\r\n        labelBlocks\r\n            .attr('x', -marginModel_1.AXIS_HORIZONTAL_LABEL_PADDING)\r\n            .attr('y', -4)\r\n            .attr('transform', 'rotate(-90)');\r\n    };\r\n    Axis.removeTicks = function (axis) {\r\n        axis.tickSize(0);\r\n    };\r\n    Axis.getAxisByOrient = function (orient, scale) {\r\n        if (orient === 'top')\r\n            return d3.axisTop(scale);\r\n        if (orient === 'bottom')\r\n            return d3.axisBottom(scale);\r\n        if (orient === 'left')\r\n            return d3.axisLeft(scale);\r\n        if (orient === 'right')\r\n            return d3.axisRight(scale);\r\n    };\r\n    Axis.setAxisFormat = function (scale, scaleOptions, axis) {\r\n        if (scaleOptions.type === 'linear') {\r\n            if (d3.max(scale.domain()) > 1000) {\r\n                axis.tickFormat(d3.format('.2s')); // examples: 1.2K, 350, 0 \r\n            }\r\n        }\r\n    };\r\n    Axis.cropLabels = function (block, scale, scaleOptions, axisOptions, blockSize) {\r\n        if (scaleOptions.type === 'point' || scaleOptions.type === 'band') {\r\n            var axisTextBlocks = block.getSvg().select(\".\" + axisOptions.cssClass).selectAll('text');\r\n            var labelSize = void 0;\r\n            if ((axisOptions.orient === 'left' || axisOptions.orient === 'right') || (axisOptions.type === 'key' && axisOptions.labels.positition === 'rotated'))\r\n                labelSize = axisOptions.labels.maxSize;\r\n            else\r\n                labelSize = scale.step();\r\n            helper_1.Helper.cropLabels(axisTextBlocks, labelSize);\r\n            if (scaleOptions.type === 'point' && axisOptions.labels.positition === 'straight' && (axisOptions.orient === 'top' || axisOptions.orient === 'bottom')) {\r\n                this.cropAndAlignExtremeLabels(block, labelSize, axisOptions, blockSize);\r\n            }\r\n        }\r\n    };\r\n    Axis.cropAndAlignExtremeLabels = function (block, labelSize, axisOptions, blockSize) {\r\n        var lastTick = block.getSvg().select(\".\" + axisOptions.cssClass).select('.tick:last-of-type');\r\n        var lastLabel = lastTick.select('text');\r\n        var translateX = helper_1.Helper.getTranslateNumbers(lastTick.attr('transform'))[0];\r\n        if (translateX + lastLabel.node().getBBox().width + axisOptions.translate.translateX > blockSize.width) {\r\n            lastLabel.attr('text-anchor', 'end');\r\n            helper_1.Helper.cropLabels(lastLabel, labelSize / 2);\r\n        }\r\n        var firtsLabel = block.getSvg()\r\n            .select(\".\" + axisOptions.cssClass)\r\n            .select('.tick:first-of-type')\r\n            .select('text');\r\n        if (axisOptions.translate.translateX - firtsLabel.node().getBBox().width < 0) {\r\n            firtsLabel.attr('text-anchor', 'start');\r\n            helper_1.Helper.cropLabels(firtsLabel, labelSize / 2);\r\n        }\r\n    };\r\n    Axis.hideLabels = function (axisElement) {\r\n        axisElement.selectAll('.tick text')\r\n            .style('display', 'none');\r\n    };\r\n    Axis.wrap = function (text, maxWidth) {\r\n        text.each(function () {\r\n            var textBlock = d3.select(this);\r\n            if (textBlock.node().getBBox().width > maxWidth) {\r\n                var letters = textBlock.text().split('').reverse(), // split text to letters.\r\n                letter = void 0, line = [], // one line. letters from this var into tpsans.\r\n                lineNumber = 0, y = textBlock.attr(\"y\"), dy = 1.4, tspan = textBlock.text(null).append(\"tspan\").attr(\"y\", y).attr(\"dy\", dy + \"em\");\r\n                while (letter = letters.pop()) {\r\n                    line.push(letter);\r\n                    tspan.text(line.join(''));\r\n                    if (tspan.node().getComputedTextLength() > maxWidth && line.length > 1) {\r\n                        line.pop();\r\n                        tspan.text(line.join(''));\r\n                        if (lineNumber === 0 && line[line.length - 1] !== ' ')\r\n                            tspan.text(tspan.text() + '-');\r\n                        line = [letter];\r\n                        if (lineNumber >= 1) { // If text block has 2 lines, text cropped.\r\n                            if (letters.length > 0)\r\n                                tspan.text(tspan.text().substr(0, tspan.text().length - 1) + '...');\r\n                            break;\r\n                        }\r\n                        tspan = textBlock.append(\"tspan\").attr(\"y\", y).attr(\"dy\", dy + \"em\").text(letter);\r\n                        lineNumber++;\r\n                    }\r\n                }\r\n                if (textBlock.selectAll('tspan').size() > 1) {\r\n                    textBlock.attr('y', -(textBlock.node().getBBox().height / 2 + 4.8));\r\n                }\r\n            }\r\n        });\r\n    };\r\n    return Axis;\r\n}());\r\nexports.Axis = Axis;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/axis/axis.ts?");

/***/ }),

/***/ "./src/engine/features/embeddedLabels/embeddedLabels.ts":
/*!**************************************************************!*\
  !*** ./src/engine/features/embeddedLabels/embeddedLabels.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EmbeddedLabels = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar valueFormatter_1 = __webpack_require__(/*! ../../valueFormatter */ \"./src/engine/valueFormatter.ts\");\r\nvar embeddedLabelsHelper_1 = __webpack_require__(/*! ./embeddedLabelsHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts\");\r\nvar EmbeddedLabels = /** @class */ (function () {\r\n    function EmbeddedLabels() {\r\n    }\r\n    EmbeddedLabels.render = function (block, bars, field, type, keyAxisOrient, blockSize, margin) {\r\n        var thisClass = this;\r\n        bars.each(function (d) {\r\n            thisClass.renderOneLabel(block, d3.select(this), d, field, type, keyAxisOrient, blockSize, margin);\r\n        });\r\n    };\r\n    EmbeddedLabels.renderOneLabel = function (block, bar, dataRow, field, type, keyAxisOrient, blockSize, margin) {\r\n        var labelBlock = block.getChartBlock()\r\n            .append('text')\r\n            .attr('class', 'embedded-label')\r\n            .style('pointer-events', 'none')\r\n            .text(valueFormatter_1.ValueFormatter.formatValue(field.format, dataRow[field.name]));\r\n        var barAttrs = {\r\n            x: helper_1.Helper.getSelectionNumericAttr(bar, 'x'),\r\n            y: helper_1.Helper.getSelectionNumericAttr(bar, 'y'),\r\n            width: helper_1.Helper.getSelectionNumericAttr(bar, 'width'),\r\n            height: helper_1.Helper.getSelectionNumericAttr(bar, 'height')\r\n        };\r\n        var labelUnserveFlag = embeddedLabelsHelper_1.EmbeddedLabelsHelper.getLabelUnserveFlag(barAttrs.height); // if bar is too small to serve label inside. This flag is needed for set outside postion and change text anchor if bar wide as whole chart block\r\n        var position = embeddedLabelsHelper_1.EmbeddedLabelsHelper.getLabelPosition(barAttrs, labelBlock.node().getBBox().width, margin, blockSize, labelUnserveFlag);\r\n        var attrs = embeddedLabelsHelper_1.EmbeddedLabelsHelper.getLabelAttrs(barAttrs, type, position, keyAxisOrient);\r\n        labelBlock\r\n            .attr('x', attrs.x)\r\n            .attr('y', attrs.y)\r\n            .attr('text-anchor', attrs.textAnchor)\r\n            .attr('dominant-baseline', 'middle');\r\n        if (position === 'inside')\r\n            labelBlock.style('fill', '#FFFFFF');\r\n        this.checkLabelsToResetTextAnchor(labelBlock, labelUnserveFlag, margin, blockSize);\r\n        this.cropText(labelBlock, barAttrs, position, labelUnserveFlag, margin, blockSize);\r\n    };\r\n    EmbeddedLabels.checkLabelsToResetTextAnchor = function (labelBlock, labelUnserveFlag, margin, blockSize) {\r\n        if (helper_1.Helper.getSelectionNumericAttr(labelBlock, 'x') + labelBlock.node().getBBox().width > blockSize.width - margin.right && labelUnserveFlag) {\r\n            labelBlock.attr('x', blockSize.width - margin.right);\r\n            labelBlock.attr('text-anchor', 'end');\r\n        }\r\n    };\r\n    EmbeddedLabels.cropText = function (labelBlock, barAttrs, position, labelUnserveFlag, margin, blockSize) {\r\n        var labelTextSpace;\r\n        if (labelUnserveFlag)\r\n            labelTextSpace = blockSize.width - margin.left - margin.right;\r\n        else\r\n            labelTextSpace = embeddedLabelsHelper_1.EmbeddedLabelsHelper.getSpaceSizeForType(position, barAttrs.width, margin, blockSize);\r\n        helper_1.Helper.cropLabels(labelBlock, labelTextSpace);\r\n    };\r\n    return EmbeddedLabels;\r\n}());\r\nexports.EmbeddedLabels = EmbeddedLabels;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/embeddedLabels/embeddedLabels.ts?");

/***/ }),

/***/ "./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts":
/*!********************************************************************!*\
  !*** ./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EmbeddedLabelsHelper = exports.LABEL_BAR_PADDING = void 0;\r\nexports.LABEL_BAR_PADDING = 6;\r\nvar MIN_BAR_HEIGHT_FOR_LABEL_SERVE = 12;\r\nvar EmbeddedLabelsHelper = /** @class */ (function () {\r\n    function EmbeddedLabelsHelper() {\r\n    }\r\n    EmbeddedLabelsHelper.getLabelPosition = function (barAttrs, labelBlockWidth, margin, blockSize, labelUnserveFlag) {\r\n        if (labelUnserveFlag || this.getSpaceSizeForType('inside', barAttrs.width, margin, blockSize) < labelBlockWidth\r\n            && this.getSpaceSizeForType('inside', barAttrs.width, margin, blockSize) < this.getSpaceSizeForType('outside', barAttrs.width, margin, blockSize))\r\n            return 'outside';\r\n        return 'inside';\r\n    };\r\n    EmbeddedLabelsHelper.getSpaceSizeForType = function (position, barWidth, margin, blockSize) {\r\n        if (position === 'outside')\r\n            return blockSize.width - margin.left - margin.right - barWidth - exports.LABEL_BAR_PADDING;\r\n        return barWidth - exports.LABEL_BAR_PADDING * 2;\r\n    };\r\n    EmbeddedLabelsHelper.getLabelAttrs = function (barAttrs, type, position, keyAxisOrient) {\r\n        return {\r\n            x: this.getLabelAttrX(barAttrs, type, position, keyAxisOrient),\r\n            y: this.getLabelAttrY(barAttrs.y, barAttrs.height),\r\n            textAnchor: this.getTextAnchor(type, position, keyAxisOrient)\r\n        };\r\n    };\r\n    EmbeddedLabelsHelper.getLabelField = function (type, chartData, index) {\r\n        if (type === 'key')\r\n            return chartData.keyField;\r\n        else if (type === 'value')\r\n            return chartData.valueFields[index];\r\n        return null;\r\n    };\r\n    EmbeddedLabelsHelper.getLabelUnserveFlag = function (barHeight) {\r\n        return barHeight < MIN_BAR_HEIGHT_FOR_LABEL_SERVE;\r\n    };\r\n    EmbeddedLabelsHelper.getLabelAttrX = function (barAttrs, type, position, keyAxisOrient) {\r\n        if (keyAxisOrient === 'left') {\r\n            if (position === 'outside')\r\n                return barAttrs.x + barAttrs.width + exports.LABEL_BAR_PADDING;\r\n            if (type === 'key')\r\n                return barAttrs.x + exports.LABEL_BAR_PADDING;\r\n            return barAttrs.x + barAttrs.width - exports.LABEL_BAR_PADDING;\r\n        }\r\n        if (position === 'outside')\r\n            return barAttrs.x - exports.LABEL_BAR_PADDING;\r\n        if (type === 'key')\r\n            return barAttrs.x + barAttrs.width - exports.LABEL_BAR_PADDING;\r\n        return barAttrs.x + exports.LABEL_BAR_PADDING;\r\n    };\r\n    EmbeddedLabelsHelper.getLabelAttrY = function (barY, barHeight) {\r\n        return barY + barHeight / 2;\r\n    };\r\n    EmbeddedLabelsHelper.getTextAnchor = function (type, position, keyAxisOrient) {\r\n        if (keyAxisOrient === 'left') {\r\n            if (position === 'outside' || type === 'key')\r\n                return 'start';\r\n            return 'end';\r\n        }\r\n        if (position === 'outside' || type === 'key')\r\n            return 'end';\r\n        return 'start';\r\n    };\r\n    return EmbeddedLabelsHelper;\r\n}());\r\nexports.EmbeddedLabelsHelper = EmbeddedLabelsHelper;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts?");

/***/ }),

/***/ "./src/engine/features/gridLine/gridLine.ts":
/*!**************************************************!*\
  !*** ./src/engine/features/gridLine/gridLine.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GridLine = void 0;\r\nvar GridLine = /** @class */ (function () {\r\n    function GridLine() {\r\n    }\r\n    GridLine.render = function (block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey) {\r\n        if (gridLineFlag.value) {\r\n            var lineLength = this.getGridLineLength('value', keyAxis, valueAxis, blockSize, margin);\r\n            var lineAttributes = this.getLineAttributes(valueAxis, lineLength);\r\n            this.renderLine(block, valueAxis, lineAttributes);\r\n        }\r\n        if (gridLineFlag.key) {\r\n            var lineLength = this.getGridLineLength('key', keyAxis, valueAxis, blockSize, margin);\r\n            var lineAttributes = this.getLineAttributes(keyAxis, lineLength);\r\n            this.renderLine(block, keyAxis, lineAttributes);\r\n            if (scaleKey.type === 'point')\r\n                this.removeGridLineOnValueAxis(block, keyAxis, valueAxis);\r\n        }\r\n    };\r\n    GridLine.rerender = function (block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey) {\r\n        this.clear(block, keyAxis.cssClass, valueAxis.cssClass);\r\n        this.render(block, gridLineFlag, keyAxis, valueAxis, blockSize, margin, scaleKey);\r\n    };\r\n    GridLine.renderLine = function (block, axis, lineAttributes) {\r\n        block\r\n            .getSvg()\r\n            .selectAll(\".\" + axis.cssClass)\r\n            .selectAll('g.tick')\r\n            .append('line')\r\n            .attr('class', this.gridLineClass)\r\n            .attr('x1', lineAttributes.x1)\r\n            .attr('y1', lineAttributes.y1)\r\n            .attr('x2', lineAttributes.x2)\r\n            .attr('y2', lineAttributes.y2);\r\n    };\r\n    GridLine.getLineAttributes = function (axis, lineLength) {\r\n        var attributes = {\r\n            x1: 0,\r\n            y1: 0,\r\n            x2: 0,\r\n            y2: 0\r\n        };\r\n        if (axis.orient === 'left' || axis.orient === 'right')\r\n            attributes.x2 = lineLength;\r\n        else\r\n            attributes.y2 = lineLength;\r\n        return attributes;\r\n    };\r\n    GridLine.clear = function (block, keyAxisClass, valueAxisClass) {\r\n        block.getSvg()\r\n            .select(\".\" + keyAxisClass + \", .\" + valueAxisClass)\r\n            .selectAll('g.tick')\r\n            .selectAll(\".\" + this.gridLineClass)\r\n            .remove();\r\n    };\r\n    GridLine.getGridLineLength = function (gridLineType, keyAxis, valueAxis, blockSize, margin) {\r\n        var axis;\r\n        var axisLength;\r\n        if (gridLineType === 'key')\r\n            axis = keyAxis;\r\n        else\r\n            axis = valueAxis;\r\n        if (axis.orient === 'left' || axis.orient === 'right')\r\n            axisLength = blockSize.width - margin.left - margin.right;\r\n        else\r\n            axisLength = blockSize.height - margin.top - margin.bottom;\r\n        if (axis.orient === 'right' || axis.orient === 'bottom')\r\n            axisLength = -axisLength;\r\n        return axisLength;\r\n    };\r\n    GridLine.removeGridLineOnValueAxis = function (block, keyAxis, valueAxis) {\r\n        if (valueAxis.orient === 'left') {\r\n            block.getSvg()\r\n                .select(\".\" + keyAxis.cssClass)\r\n                .select('g.tick')\r\n                .select(\".\" + this.gridLineClass)\r\n                .remove();\r\n        }\r\n        else if (valueAxis.orient === 'right') {\r\n            block.getSvg()\r\n                .select(\".\" + keyAxis.cssClass)\r\n                .select('g.tick:last-of-type')\r\n                .select(\".\" + this.gridLineClass)\r\n                .remove();\r\n        }\r\n    };\r\n    GridLine.gridLineClass = 'grid-line';\r\n    return GridLine;\r\n}());\r\nexports.GridLine = GridLine;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/gridLine/gridLine.ts?");

/***/ }),

/***/ "./src/engine/features/legend/legend.ts":
/*!**********************************************!*\
  !*** ./src/engine/features/legend/legend.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Legend = void 0;\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar Legend = /** @class */ (function () {\r\n    function Legend() {\r\n    }\r\n    Legend.render = function (block, data, options, legendBlockModel, blockSize) {\r\n        if (options.legend.position !== 'off') {\r\n            var legendItemsContent = this.getLegendItemsContent(options, data);\r\n            var chartElementsColor = this.getMarksColor(options);\r\n            var legendItemsDirection = this.getLegendItemsDirection(options.type, options.legend.position);\r\n            this.renderLegendBlock(block, legendItemsContent, options.legend.position, legendBlockModel, chartElementsColor, blockSize, legendItemsDirection);\r\n        }\r\n    };\r\n    Legend.renderLegendBlock = function (block, items, legendPosition, legendBlockModel, colorPalette, blockSize, itemsDirection) {\r\n        var legendBlock = block.getSvg()\r\n            .append('foreignObject')\r\n            .attr('class', 'legend-object');\r\n        var legendCoordinate = this.getLegendCoordinateByPosition(legendPosition, legendBlockModel, blockSize);\r\n        this.fillLegendCoordinate(legendBlock, legendCoordinate);\r\n        this.renderLegendContent(legendBlock, items, colorPalette, itemsDirection, legendPosition);\r\n    };\r\n    Legend.getLegendItemsContent = function (options, data) {\r\n        if (options.type === '2d') {\r\n            var texts_1 = [];\r\n            options.charts.forEach(function (chart) {\r\n                texts_1 = texts_1.concat(chart.data.valueFields.map(function (field) { return field.title; }));\r\n            });\r\n            return texts_1;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return options.charts.map(function (chart) { return data[chart.data.dataSource].map(function (record) { return record[chart.data.keyField.name]; }); })[0];\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return options.charts.map(function (chart) { return chart.title; });\r\n        }\r\n    };\r\n    Legend.getMarksColor = function (options) {\r\n        if (options.type === '2d') {\r\n            var colors_1 = [];\r\n            options.charts.forEach(function (chart) {\r\n                colors_1 = colors_1.concat(chart.style.elementColors);\r\n            });\r\n            return colors_1;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return options.charts.map(function (chart) { return chart.style.elementColors; })[0];\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return options.charts.map(function (chart) { return chart.style.elementColors[0]; });\r\n        }\r\n    };\r\n    Legend.getLegendCoordinateByPosition = function (legendPosition, legendBlockModel, blockSize) {\r\n        var legendModel = legendBlockModel[legendPosition];\r\n        var coordinate = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        if (legendPosition === 'left' || legendPosition === 'right') {\r\n            coordinate.y = legendModel.margin.top;\r\n            coordinate.width = legendModel.size;\r\n            coordinate.height = blockSize.height - legendModel.margin.top - legendModel.margin.bottom;\r\n        }\r\n        else if (legendPosition === 'bottom' || legendPosition === 'top') {\r\n            coordinate.x = legendModel.margin.left;\r\n            coordinate.width = blockSize.width - legendModel.margin.left - legendModel.margin.right;\r\n            coordinate.height = legendModel.size;\r\n        }\r\n        if (legendPosition === 'left')\r\n            coordinate.x = legendModel.margin.left;\r\n        else if (legendPosition === 'right')\r\n            coordinate.x = blockSize.width - legendModel.size - legendModel.margin.right;\r\n        else if (legendPosition === 'top')\r\n            coordinate.y = legendModel.margin.top;\r\n        else if (legendPosition === 'bottom')\r\n            coordinate.y = blockSize.height - legendModel.size - legendModel.margin.bottom;\r\n        return coordinate;\r\n    };\r\n    Legend.fillLegendCoordinate = function (legendBlock, coordinate) {\r\n        legendBlock\r\n            .attr('x', coordinate.x)\r\n            .attr('y', coordinate.y)\r\n            .attr('width', coordinate.width)\r\n            .attr('height', coordinate.height);\r\n    };\r\n    Legend.renderLegendContent = function (legendBlock, items, colorPalette, itemsDirection, position) {\r\n        var wrapper = legendBlock.append('xhtml:div')\r\n            .attr('class', 'legend-block');\r\n        wrapper\r\n            .style('height', '100%')\r\n            .style('display', 'flex');\r\n        if (itemsDirection === 'column') {\r\n            wrapper.style('flex-direction', 'column');\r\n        }\r\n        var itemWrappers = wrapper\r\n            .selectAll('.legend-item')\r\n            .data(items)\r\n            .enter()\r\n            .append('div')\r\n            .attr('class', this.getItemClasses(itemsDirection, position));\r\n        itemWrappers\r\n            .append('span')\r\n            .attr('class', 'legend-circle')\r\n            .style('background-color', function (d, i) { return colorPalette[i % colorPalette.length].toString(); });\r\n        itemWrappers\r\n            .data(items)\r\n            .append('span')\r\n            .attr('class', this.getLegendLabelClassByPosition(position))\r\n            .text(function (d) { return d.toString(); });\r\n        if (itemsDirection === 'column' && position === 'bottom')\r\n            this.cropColumnLabels(legendBlock, itemWrappers, itemsDirection);\r\n        if (itemsDirection === 'row')\r\n            this.cropRowLabels(legendBlock, itemWrappers);\r\n    };\r\n    Legend.cropRowLabels = function (legendBlock, items) {\r\n        var _this = this;\r\n        var maxWidth = legendBlock.node().getBoundingClientRect().width;\r\n        var sumOfItemsWidth = this.getSumOfItemsWidths(items);\r\n        var maxItemWidth = this.getMaxItemWidth(legendBlock, items, 'row');\r\n        var index = 0;\r\n        var loopFlag = true; // if at least one label has no text, loop ends\r\n        while (sumOfItemsWidth > maxWidth && loopFlag) {\r\n            items.nodes().forEach(function (node) {\r\n                var textBlock = node.querySelector('.legend-label');\r\n                if (node.getBoundingClientRect().width > maxItemWidth && textBlock.textContent) {\r\n                    var labelText = index > 0\r\n                        ? textBlock.textContent.substr(0, textBlock.textContent.length - 3)\r\n                        : textBlock.textContent;\r\n                    labelText = labelText.substr(0, labelText.length - 1);\r\n                    textBlock.textContent = labelText + '...';\r\n                    sumOfItemsWidth = _this.getSumOfItemsWidths(items);\r\n                    if (labelText.length === 0) {\r\n                        textBlock.textContent = '';\r\n                        loopFlag = false;\r\n                    }\r\n                }\r\n            });\r\n            index++;\r\n        }\r\n    };\r\n    Legend.cropColumnLabels = function (legendBlock, items, itemsDirection) {\r\n        var maxItemWidth = this.getMaxItemWidth(legendBlock, items, itemsDirection);\r\n        items.nodes().forEach(function (node) {\r\n            if (node.getBoundingClientRect().width > maxItemWidth) {\r\n                var text_1 = node.querySelector('.legend-label');\r\n                var labelText = text_1.textContent;\r\n                while (node.getBoundingClientRect().width > maxItemWidth && labelText.length > 3) {\r\n                    labelText = labelText.substr(0, labelText.length - 1);\r\n                    text_1.textContent = labelText + '...';\r\n                }\r\n            }\r\n        });\r\n    };\r\n    Legend.getMaxItemWidth = function (legendBlock, items, itemsDirection) {\r\n        if (itemsDirection === 'row') {\r\n            var margins = items.nodes().map(function (node) { return helper_1.Helper.getPXValueFromString(helper_1.Helper.getCssPropertyValue(node, 'margin-left')); });\r\n            var sumOfMargins = helper_1.Helper.getSumOfNumbers(margins);\r\n            return (parseFloat(legendBlock.attr('width')) - sumOfMargins) / items.size();\r\n        }\r\n        return parseFloat(legendBlock.attr('width'));\r\n    };\r\n    Legend.getItemClasses = function (itemsDirection, position) {\r\n        var cssClasses = this.getLegendItemClassByDirection(itemsDirection);\r\n        if (itemsDirection === 'column')\r\n            cssClasses += \" \" + this.getLegendItemsMarginClass(position);\r\n        return cssClasses;\r\n    };\r\n    Legend.getLegendItemClassByDirection = function (itemsDirection) {\r\n        return itemsDirection === 'column' ? 'legend-item-row' : 'legend-item-inline';\r\n    };\r\n    Legend.getLegendItemsMarginClass = function (legendPosition) {\r\n        return legendPosition === 'right' ? 'mt-15' : 'mt-10';\r\n    };\r\n    Legend.getLegendLabelClassByPosition = function (position) {\r\n        if (position === 'top' || position === 'bottom')\r\n            return 'legend-label legend-label-nowrap';\r\n        return 'legend-label';\r\n    };\r\n    Legend.getLegendItemsDirection = function (chartNotation, legendPosition) {\r\n        if (legendPosition === 'right' || legendPosition === 'left')\r\n            return 'column';\r\n        else\r\n            return chartNotation === 'polar' ? 'column' : 'row';\r\n    };\r\n    Legend.getSumOfItemsWidths = function (items) {\r\n        var sumOfItemsWidth = helper_1.Helper.getSumOfNumbers(items.nodes().map(function (node) { return node.getBoundingClientRect().width; }));\r\n        sumOfItemsWidth += helper_1.Helper.getSumOfNumbers(items.nodes().map(function (node) { return helper_1.Helper.getPXValueFromString(helper_1.Helper.getCssPropertyValue(node, 'margin-left')); }));\r\n        return sumOfItemsWidth;\r\n    };\r\n    return Legend;\r\n}());\r\nexports.Legend = Legend;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/legend/legend.ts?");

/***/ }),

/***/ "./src/engine/features/lineDots/dot.ts":
/*!*********************************************!*\
  !*** ./src/engine/features/lineDots/dot.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Dot = void 0;\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar Dot = /** @class */ (function () {\r\n    function Dot() {\r\n    }\r\n    Dot.render = function (block, data, keyAxisOrient, scales, margin, keyField, valueField, cssClasses, itemIndex, colorPalette, blockSize, isSegmented) {\r\n        var dotsWrapper = block.getChartBlock()\r\n            .selectAll(\".\" + this.dotClass + helper_1.Helper.getCssClassesLine(cssClasses) + \".chart-index-\" + itemIndex)\r\n            .data(data)\r\n            .enter();\r\n        var attrs = this.getDotAttrs(keyAxisOrient, scales, margin, keyField, valueField, isSegmented);\r\n        var dots = dotsWrapper.append('circle')\r\n            .attr('class', this.dotClass)\r\n            .attr('cx', function (d) { return attrs.cx(d); })\r\n            .attr('cy', function (d) { return attrs.cy(d); })\r\n            .attr('r', this.dotRadius)\r\n            .style('clip-path', \"url(\" + block.getClipPathId() + \")\");\r\n        var dotsInside = dotsWrapper.append('circle')\r\n            .attr('class', this.innerDotClass)\r\n            .attr('cx', function (d) { return attrs.cx(d); })\r\n            .attr('cy', function (d) { return attrs.cy(d); })\r\n            .attr('r', this.innerDotRadius)\r\n            .style('fill', 'white')\r\n            .style('pointer-events', 'none');\r\n        // DotArea.render(block, dotsWrapper, attrs, keyField, cssClasses, this.dotClass);\r\n        helper_1.Helper.setCssClasses(dots, helper_1.Helper.getCssClassesWithElementIndex(cssClasses, itemIndex));\r\n        helper_1.Helper.setCssClasses(dotsInside, helper_1.Helper.getCssClassesWithElementIndex(cssClasses, itemIndex));\r\n        helper_1.Helper.setChartElementColor(dots, colorPalette, itemIndex, 'fill');\r\n    };\r\n    Dot.getAllDots = function (block, chartCssClasses) {\r\n        return block.getSvg()\r\n            .selectAll(\".\" + this.dotClass + helper_1.Helper.getCssClassesLine(chartCssClasses));\r\n    };\r\n    Dot.updateDotsCoordinateByValueAxis = function (block, data, keyAxisOrient, scales, margin, keyField, valueField, cssClasses, index, isSegmented) {\r\n        var dots = block.getChartBlock()\r\n            .selectAll(\".\" + this.dotClass + helper_1.Helper.getCssClassesLine(cssClasses) + \".chart-element-\" + index)\r\n            .data(data);\r\n        var attrs = this.getDotAttrs(keyAxisOrient, scales, margin, keyField, valueField, isSegmented);\r\n        dots\r\n            .transition()\r\n            .duration(1000)\r\n            .attr('cx', function (d) { return attrs.cx(d); })\r\n            .attr('cy', function (d) { return attrs.cy(d); });\r\n        block.getChartBlock()\r\n            .selectAll(\".\" + this.innerDotClass + helper_1.Helper.getCssClassesLine(cssClasses) + \".chart-element-\" + index)\r\n            .data(data)\r\n            .transition()\r\n            .duration(1000)\r\n            .attr('cx', function (d) { return attrs.cx(d); })\r\n            .attr('cy', function (d) { return attrs.cy(d); });\r\n    };\r\n    Dot.getDotAttrs = function (keyAxisOrient, scales, margin, keyField, valueField, isSegmented) {\r\n        var _this = this;\r\n        var attrs = { cx: null, cy: null };\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            attrs.cx = function (d) { return scales.scaleValue(d[valueField]) + margin.left; };\r\n            attrs.cy = function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, _this.getKeyFieldValue(d, keyField, isSegmented)) + margin.top; };\r\n        }\r\n        else if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            attrs.cx = function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, _this.getKeyFieldValue(d, keyField, isSegmented)) + margin.left; },\r\n                attrs.cy = function (d) { return scales.scaleValue(d[valueField]) + margin.top; };\r\n        }\r\n        return attrs;\r\n    };\r\n    Dot.getKeyFieldValue = function (row, keyFieldName, isSegmented) {\r\n        return isSegmented ? row.data[keyFieldName] : row[keyFieldName];\r\n    };\r\n    Dot.dotClass = 'dot';\r\n    Dot.innerDotClass = 'dot-inside';\r\n    Dot.dotRadius = 5.5;\r\n    Dot.innerDotRadius = 2.5;\r\n    return Dot;\r\n}());\r\nexports.Dot = Dot;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/lineDots/dot.ts?");

/***/ }),

/***/ "./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts":
/*!************************************************************************!*\
  !*** ./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RecordOverflowAlert = void 0;\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar RecordOverflowAlert = /** @class */ (function () {\r\n    function RecordOverflowAlert() {\r\n    }\r\n    RecordOverflowAlert.render = function (block, hidedRecordsAmount, position, chartOrientation) {\r\n        if (chartOrientation === void 0) { chartOrientation = null; }\r\n        var alertBlock = block.getWrapper()\r\n            .append('div')\r\n            .attr('class', 'record-overflow-alert')\r\n            .text(this.getAlertText(hidedRecordsAmount, chartOrientation));\r\n        var attrs = this.getBlockPositionAttrs(position, block);\r\n        this.setAlertPosition(alertBlock, attrs);\r\n    };\r\n    RecordOverflowAlert.setAlertPosition = function (alertBlock, attrs) {\r\n        alertBlock\r\n            .style('position', 'absolute')\r\n            .style('left', attrs.left)\r\n            .style('right', attrs.right)\r\n            .style('top', attrs.top)\r\n            .style('bottom', attrs.bottom);\r\n    };\r\n    RecordOverflowAlert.getAlertText = function (hidedRecordsAmount, chartOrientation) {\r\n        return \"+ \" + hidedRecordsAmount + \" \" + this.getWordTextEndingByAmount(hidedRecordsAmount, chartOrientation);\r\n    };\r\n    RecordOverflowAlert.getWordTextEndingByAmount = function (hidedRecordsAmount, chartOrientation) {\r\n        var lastDigit = hidedRecordsAmount % 10;\r\n        if (chartOrientation === 'vertical') {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'столбцов';\r\n            if (lastDigit === 1)\r\n                return 'столбец';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'столбца';\r\n            return 'столбцов';\r\n        }\r\n        else if (chartOrientation === 'horizontal') {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'строк';\r\n            if (lastDigit === 1)\r\n                return 'строка';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'строки';\r\n            return 'строк';\r\n        }\r\n        else {\r\n            if (hidedRecordsAmount >= 10 && hidedRecordsAmount <= 20)\r\n                return 'категорий';\r\n            if (lastDigit === 1)\r\n                return 'категория';\r\n            if (lastDigit >= 2 && lastDigit <= 4)\r\n                return 'категории';\r\n            return 'категорий';\r\n        }\r\n    };\r\n    RecordOverflowAlert.getBlockPositionAttrs = function (position, block) {\r\n        var attrs = {\r\n            bottom: null,\r\n            top: null,\r\n            right: null,\r\n            left: null\r\n        };\r\n        if (position === 'top') {\r\n            attrs.right = '17px';\r\n            attrs.top = '1rem';\r\n        }\r\n        if (position === 'right') {\r\n            attrs.bottom = '20px';\r\n            attrs.left = this.getLeftAttrForRightBlock(block) + 'px';\r\n        }\r\n        if (position === 'bottom') {\r\n            attrs.left = '20px';\r\n            attrs.bottom = '20px';\r\n        }\r\n        return attrs;\r\n    };\r\n    RecordOverflowAlert.getLeftAttrForRightBlock = function (block) {\r\n        var legendBlock = block.getSvg().select('.legend-object');\r\n        if (legendBlock.empty())\r\n            return null;\r\n        return helper_1.Helper.getSelectionNumericAttr(legendBlock, 'x');\r\n    };\r\n    return RecordOverflowAlert;\r\n}());\r\nexports.RecordOverflowAlert = RecordOverflowAlert;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/recordOverflowAlert/recordOverflowAlert.ts?");

/***/ }),

/***/ "./src/engine/features/scale/scale.ts":
/*!********************************************!*\
  !*** ./src/engine/features/scale/scale.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Scale = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar Scale = /** @class */ (function () {\r\n    function Scale() {\r\n    }\r\n    Scale.getScales = function (scaleKey, scaleValue, bandSettings) {\r\n        var scales = {\r\n            scaleKey: null,\r\n            scaleValue: null\r\n        };\r\n        if (scaleKey.type === 'band')\r\n            scales.scaleKey = this.getScaleBand(scaleKey.domain, scaleKey.range, bandSettings, scaleKey.elementsAmount);\r\n        else if (scaleKey.type === 'point')\r\n            scales.scaleKey = this.getScalePoint(scaleKey.domain, scaleKey.range);\r\n        if (scaleValue.type === 'linear')\r\n            scales.scaleValue = this.getScaleLinear(scaleValue.domain, scaleValue.range);\r\n        else if (scaleValue.type === 'datetime')\r\n            scales.scaleValue = this.getScaleTime(scaleValue.domain, scaleValue.range);\r\n        return scales;\r\n    };\r\n    Scale.getScaleWidth = function (scale) {\r\n        if (scale.bandwidth && scale.bandwidth() !== 0) {\r\n            return scale.bandwidth();\r\n        }\r\n        else if (scale.step) {\r\n            return scale.step();\r\n        }\r\n    };\r\n    Scale.getScaleStep = function (scale) {\r\n        if (scale.step) {\r\n            return scale.step();\r\n        }\r\n    };\r\n    Scale.getScaleKeyPoint = function (scale, value) {\r\n        if (scale.bandwidth && scale.bandwidth() !== 0) {\r\n            return scale(value) + this.getScaleWidth(scale) / 2;\r\n        }\r\n        return scale(value);\r\n    };\r\n    Scale.getScaleBand = function (domain, range, bandSettings, elementsInGroupAmount) {\r\n        var scale = d3.scaleBand()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n        var bandSize = scale.bandwidth();\r\n        if (bandSettings.groupMinDistance < bandSize) {\r\n            scale.paddingInner(bandSettings.groupMinDistance / bandSize);\r\n            scale.paddingOuter(bandSettings.groupMinDistance / bandSize / 2);\r\n        }\r\n        // Padding inner = 10. If bandwidth more than needed, paddingInner is increased to number less than 35 \r\n        var paddingInner = bandSettings.groupMinDistance;\r\n        while (scale.bandwidth() > bandSettings.maxBarWidth * elementsInGroupAmount + bandSettings.barDistance * (elementsInGroupAmount - 1) && paddingInner < bandSettings.groupMaxDistance) {\r\n            scale.paddingInner(++paddingInner / bandSize);\r\n        }\r\n        // if bandwidth more than all bars widths in group + distance between it + distance between groups\r\n        var paddingOuter = 1;\r\n        while (scale.step() > bandSettings.maxBarWidth * elementsInGroupAmount + bandSettings.groupMaxDistance + bandSettings.barDistance * (elementsInGroupAmount - 1)) {\r\n            scale.paddingOuter(++paddingOuter / bandSize);\r\n        }\r\n        return scale;\r\n    };\r\n    Scale.getScaleLinear = function (domain, range) {\r\n        return d3.scaleLinear()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n    };\r\n    Scale.getScalePoint = function (domain, range) {\r\n        return d3.scalePoint()\r\n            .domain(domain)\r\n            .range([range.start, range.end]);\r\n    };\r\n    Scale.getScaleTime = function (domain, range) {\r\n        return d3.scaleTime()\r\n            .domain(domain)\r\n            .range([range.start, range.end])\r\n            .nice();\r\n    };\r\n    return Scale;\r\n}());\r\nexports.Scale = Scale;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/scale/scale.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltip.ts":
/*!************************************************!*\
  !*** ./src/engine/features/tolltip/tooltip.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Tooltip = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar tooltipHelper_1 = __webpack_require__(/*! ./tooltipHelper */ \"./src/engine/features/tolltip/tooltipHelper.ts\");\r\nvar donut_1 = __webpack_require__(/*! ../../polarNotation/donut */ \"./src/engine/polarNotation/donut.ts\");\r\nvar bar_1 = __webpack_require__(/*! ../../twoDimensionalNotation/bar/bar */ \"./src/engine/twoDimensionalNotation/bar/bar.ts\");\r\nvar dot_1 = __webpack_require__(/*! ../lineDots/dot */ \"./src/engine/features/lineDots/dot.ts\");\r\nvar Tooltip = /** @class */ (function () {\r\n    function Tooltip() {\r\n    }\r\n    Tooltip.renderTooltips = function (block, model, data) {\r\n        this.renderTooltipWrapper(block);\r\n        var chartsWithTooltipIndex = model.options.charts.findIndex(function (chart) { return chart.tooltip.data.fields.length !== 0; });\r\n        if (chartsWithTooltipIndex !== -1) {\r\n            if (model.options.type === '2d') {\r\n                this.rednerTooltipFor2DCharts(block, model.chartBlock.margin, model.options.charts, data, model.options.isSegmented, model.blockCanvas.size, model.options.orient);\r\n            }\r\n            else if (model.options.type === 'polar') {\r\n                this.renderTooltipsForDonut(block, model.options.charts, data, model.blockCanvas.size, model.chartBlock.margin, donut_1.Donut.getThickness(model.chartSettings.donut, model.blockCanvas.size, model.chartBlock.margin));\r\n            }\r\n            else if (model.options.type === 'interval') {\r\n                this.renderTooltipsForInterval(block, model.options.charts, data, model.blockCanvas.size, model.options.orient);\r\n            }\r\n        }\r\n    };\r\n    Tooltip.rednerTooltipFor2DCharts = function (block, margin, charts, data, isSegmented, blockSize, chartOrientation) {\r\n        var _this = this;\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'bar') {\r\n                _this.renderTooltipForBars(block, bar_1.Bar.getAllBarItems(block), data, chart, isSegmented, chartOrientation, blockSize, margin, charts.map(function (ch) { return tooltipHelper_1.TooltipHelper.getChartStyleSettings(ch); }));\r\n            }\r\n            else if (chart.type === 'line' || chart.type === 'area') {\r\n                _this.renderTooltipForDots(block, dot_1.Dot.getAllDots(block, chart.cssClasses), data, chart, isSegmented, blockSize, charts.map(function (ch) { return tooltipHelper_1.TooltipHelper.getChartStyleSettings(ch); }));\r\n            }\r\n        });\r\n    };\r\n    Tooltip.renderTooltipsForDonut = function (block, charts, data, blockSize, margin, chartThickness) {\r\n        var _this = this;\r\n        charts.forEach(function (chart) {\r\n            var attrTransform = block.getSvg().select(\".\" + donut_1.Donut.donutBlockClass).attr('transform');\r\n            var translateNumbers = helper_1.Helper.getTranslateNumbers(attrTransform);\r\n            var translateX = translateNumbers[0];\r\n            var translateY = translateNumbers[1];\r\n            var arcItems = donut_1.Donut.getAllArcs(block);\r\n            _this.renderTooltipForDonut(block, arcItems, data, chart, blockSize, margin, chartThickness, translateX, translateY);\r\n        });\r\n    };\r\n    Tooltip.renderTooltipsForInterval = function (block, charts, data, blockSize, chartOrientation) {\r\n        var _this = this;\r\n        charts.forEach(function (chart) {\r\n            if (chart.tooltip.data.fields.length !== 0) {\r\n                var bars = block.getSvg()\r\n                    .selectAll(\"rect\" + helper_1.Helper.getCssClassesLine(chart.cssClasses));\r\n                _this.renderTooltipForGantt(block, bars, data, chart, chartOrientation, blockSize);\r\n            }\r\n        });\r\n    };\r\n    Tooltip.renderTooltipForDots = function (block, elemets, data, chart, isSegmented, blockSize, chartsStyleSettings) {\r\n        var tooltipBlock = this.renderTooltipBlock(block);\r\n        var tooltipContent = this.renderTooltipContentBlock(tooltipBlock);\r\n        var tooltipArrow = this.renderTooltipArrow(tooltipBlock);\r\n        var thisClass = this;\r\n        var otherChartsElements = tooltipHelper_1.TooltipHelper.getOtherChartsElements(block, chart.index, chartsStyleSettings.map(function (ch) { return ch.cssClasses; }));\r\n        elemets\r\n            .on('mouseover', function (event, d) {\r\n            tooltipBlock.style('display', 'block');\r\n            var keyValue = tooltipHelper_1.TooltipHelper.getKeyForTooltip(d, chart.data.keyField.name, isSegmented);\r\n            var index = tooltipHelper_1.TooltipHelper.getElementIndex(elemets, this, keyValue, chart.data.keyField.name, isSegmented);\r\n            tooltipContent.html(\"\" + tooltipHelper_1.TooltipHelper.getTooltipHtmlFor2DChart(chart, data, keyValue, index));\r\n            var coordinatePointer = tooltipHelper_1.TooltipHelper.getTooltipBlockCoordinateByDot(d3.select(this), tooltipBlock, blockSize, tooltipArrow);\r\n            var tooltipCoordinate = tooltipHelper_1.TooltipHelper.getTooltipCoordinate(coordinatePointer);\r\n            thisClass.setTooltipCoordinate(tooltipBlock, tooltipCoordinate);\r\n            var dotsEdgingAttrs = tooltipHelper_1.TooltipHelper.getDotEdgingAttrs(d3.select(this));\r\n            thisClass.renderDotsEdging(block, dotsEdgingAttrs, chart.style.elementColors[index].toString());\r\n            tooltipHelper_1.TooltipHelper.setElementsSemiOpacity(otherChartsElements);\r\n        });\r\n        elemets.on('mouseleave', function () {\r\n            thisClass.removeDotsEdging(block);\r\n            tooltipBlock.style('display', 'none');\r\n            tooltipHelper_1.TooltipHelper.setOtherChartsElementsDefaultOpacity(otherChartsElements, chartsStyleSettings);\r\n        });\r\n    };\r\n    Tooltip.renderTooltipForBars = function (block, elemets, data, chart, isSegmented, chartOrientation, blockSize, margin, chartsStyleSettings) {\r\n        var tooltipBlock = this.renderTooltipBlock(block);\r\n        var tooltipContent = this.renderTooltipContentBlock(tooltipBlock);\r\n        var tooltipArrow = this.renderTooltipArrow(tooltipBlock);\r\n        var thisClass = this;\r\n        var isGrouped;\r\n        if (chartOrientation === 'vertical')\r\n            isGrouped = parseFloat(elemets.attr('width')) < 10; // grouping bar by one bar width\r\n        else\r\n            isGrouped = parseFloat(elemets.attr('height')) < 10;\r\n        var otherChartsElements = tooltipHelper_1.TooltipHelper.getOtherChartsElements(block, chart.index, chartsStyleSettings.map(function (ch) { return ch.cssClasses; }));\r\n        var barHighlighter;\r\n        elemets\r\n            .on('mouseover', function (event, dataRow) {\r\n            tooltipBlock.style('display', 'block');\r\n            var keyValue = tooltipHelper_1.TooltipHelper.getKeyForTooltip(dataRow, chart.data.keyField.name, isSegmented);\r\n            if (isGrouped) {\r\n                tooltipContent.html(tooltipHelper_1.TooltipHelper.getMultyTooltipHtmlFor2DChart(chart, data, keyValue));\r\n            }\r\n            else {\r\n                var index = tooltipHelper_1.TooltipHelper.getElementIndex(elemets, this, keyValue, chart.data.keyField.name, isSegmented);\r\n                tooltipContent.html(tooltipHelper_1.TooltipHelper.getTooltipHtmlFor2DChart(chart, data, keyValue, index));\r\n            }\r\n            var coordinatePointer = tooltipHelper_1.TooltipHelper.getTooltipBlockCoordinateByRect(d3.select(this), tooltipBlock, blockSize, tooltipArrow, chartOrientation);\r\n            var tooltipCoordinate = tooltipHelper_1.TooltipHelper.getTooltipCoordinate(coordinatePointer);\r\n            thisClass.setTooltipCoordinate(tooltipBlock, tooltipCoordinate);\r\n            tooltipHelper_1.TooltipHelper.setElementsSemiOpacity(otherChartsElements);\r\n            var highlighterAttrs = tooltipHelper_1.TooltipHelper.getBarHighlighterAttrs(d3.select(this), chartOrientation, blockSize, margin);\r\n            barHighlighter = thisClass.renderBarHighlighter(block, highlighterAttrs);\r\n        });\r\n        elemets.on('mouseleave', function () {\r\n            tooltipBlock.style('display', 'none');\r\n            tooltipHelper_1.TooltipHelper.setElementsFullOpacity(elemets);\r\n            tooltipHelper_1.TooltipHelper.setOtherChartsElementsDefaultOpacity(otherChartsElements, chartsStyleSettings);\r\n            barHighlighter.remove();\r\n        });\r\n    };\r\n    Tooltip.renderTooltipForDonut = function (block, elemets, data, chart, blockSize, margin, donutThickness, translateX, translateY) {\r\n        if (translateX === void 0) { translateX = 0; }\r\n        if (translateY === void 0) { translateY = 0; }\r\n        var tooltipBlock = this.renderTooltipBlock(block, translateX, translateY);\r\n        var tooltipContent = this.renderTooltipContentBlock(tooltipBlock);\r\n        var tooltipArrow = this.renderTooltipArrow(tooltipBlock);\r\n        var thisClass = this;\r\n        elemets\r\n            .on('mouseover', function (event, dataRow) {\r\n            tooltipBlock.style('display', 'block');\r\n            var key = dataRow.data[chart.data.keyField.name];\r\n            tooltipContent.html(tooltipHelper_1.TooltipHelper.getTooltipHtmlForPolarChart(chart, data, key, d3.select(this).select('path').style('fill')));\r\n            var coordinatePointer = tooltipHelper_1.TooltipHelper.getRecalcedCoordinateByArrow(donut_1.Donut.getArcCentroid(blockSize, margin, dataRow, donutThickness), tooltipBlock, blockSize, tooltipArrow, translateX, translateY);\r\n            var tooltipCoordinate = tooltipHelper_1.TooltipHelper.getTooltipCoordinate(coordinatePointer);\r\n            thisClass.setTooltipCoordinate(tooltipBlock, tooltipCoordinate);\r\n            tooltipHelper_1.TooltipHelper.setElementsSemiOpacity(elemets.filter(function (d) { return d.data[chart.data.keyField.name] !== key; }));\r\n        });\r\n        elemets.on('mouseleave', function () {\r\n            tooltipBlock.style('display', 'none');\r\n            tooltipHelper_1.TooltipHelper.setElementsFullOpacity(elemets);\r\n        });\r\n    };\r\n    Tooltip.renderTooltipForGantt = function (block, elemets, data, chart, chartOrientation, blockSize) {\r\n        var tooltipBlock = this.renderTooltipBlock(block);\r\n        var tooltipContent = this.renderTooltipContentBlock(tooltipBlock);\r\n        var tooltipArrow = this.renderTooltipArrow(tooltipBlock);\r\n        var thisClass = this;\r\n        elemets\r\n            .on('mouseover', function (event, dataRow) {\r\n            tooltipBlock.style('display', 'block');\r\n            var key = tooltipHelper_1.TooltipHelper.getKeyForTooltip(dataRow, chart.data.keyField.name, false);\r\n            tooltipContent.html(\"\" + tooltipHelper_1.TooltipHelper.getTooltipHtmlForIntervalChart(chart, data, key, d3.select(this).style('fill')));\r\n            var coordinatePointer = tooltipHelper_1.TooltipHelper.getTooltipBlockCoordinateByRect(d3.select(this), tooltipBlock, blockSize, tooltipArrow, chartOrientation);\r\n            var tooltipCoordinate = tooltipHelper_1.TooltipHelper.getTooltipCoordinate(coordinatePointer);\r\n            thisClass.setTooltipCoordinate(tooltipBlock, tooltipCoordinate);\r\n            tooltipHelper_1.TooltipHelper.setElementsSemiOpacity(tooltipHelper_1.TooltipHelper.getFilteredElements(elemets, chart.data.keyField.name, key, false));\r\n        });\r\n        elemets.on('mouseleave', function () {\r\n            tooltipHelper_1.TooltipHelper.setElementsFullOpacity(elemets);\r\n            tooltipBlock.style('display', 'none');\r\n        });\r\n    };\r\n    Tooltip.renderTooltipWrapper = function (block) {\r\n        block.getWrapper()\r\n            .append('div')\r\n            .attr('class', this.tooltipWrapperClass);\r\n    };\r\n    Tooltip.renderTooltipArrow = function (tooltipBlock) {\r\n        var tooltipArrow = tooltipBlock.select(\".\" + this.tooltipArrowClass);\r\n        if (tooltipArrow.empty())\r\n            tooltipArrow = tooltipBlock\r\n                .append('div')\r\n                .attr('class', this.tooltipArrowClass)\r\n                .style('position', 'absolute')\r\n                .style('left', tooltipHelper_1.ARROW_DEFAULT_POSITION + \"px\")\r\n                .style('bottom', '-6px')\r\n                .style('width', tooltipHelper_1.ARROW_SIZE + \"px\")\r\n                .style('height', tooltipHelper_1.ARROW_SIZE + \"px\");\r\n        return tooltipArrow;\r\n    };\r\n    Tooltip.renderTooltipBlock = function (block, translateX, translateY) {\r\n        if (translateX === void 0) { translateX = 0; }\r\n        if (translateY === void 0) { translateY = 0; }\r\n        var wrapper = block.getWrapper().select(\".\" + this.tooltipWrapperClass);\r\n        var tooltipBlock = wrapper.select(\".\" + this.tooltipBlockClass);\r\n        if (tooltipBlock.empty()) {\r\n            tooltipBlock = wrapper\r\n                .append('div')\r\n                .attr('class', this.tooltipBlockClass)\r\n                .style('position', 'absolute')\r\n                .style('display', 'none');\r\n        }\r\n        if (translateX !== 0 || translateY !== 0)\r\n            tooltipBlock.style('transform', \"translate(\" + translateX + \"px, \" + translateY + \"px)\");\r\n        return tooltipBlock;\r\n    };\r\n    Tooltip.renderTooltipContentBlock = function (tooltipBlock) {\r\n        var tooltipContentBlock = tooltipBlock.select(\"div.\" + this.tooltipContentClass);\r\n        if (tooltipContentBlock.empty())\r\n            tooltipContentBlock = tooltipBlock.append('div')\r\n                .attr('class', this.tooltipContentClass);\r\n        return tooltipContentBlock;\r\n    };\r\n    Tooltip.setTooltipCoordinate = function (tooltipBlock, tooltipCoordinate) {\r\n        tooltipBlock\r\n            .style('left', tooltipCoordinate.left)\r\n            .style('top', tooltipCoordinate.top)\r\n            .style('right', tooltipCoordinate.right)\r\n            .style('bottom', tooltipCoordinate.bottom);\r\n    };\r\n    Tooltip.renderDotsEdging = function (block, attrs, color) {\r\n        block.getChartBlock()\r\n            .insert('circle', \".\" + dot_1.Dot.dotClass)\r\n            .attr('class', 'dot-edging-internal')\r\n            .attr('cx', attrs.cx)\r\n            .attr('cy', attrs.cy)\r\n            .attr('r', 10.5)\r\n            .style('opacity', 0.4)\r\n            .style('fill', color)\r\n            .style('pointer-events', 'none');\r\n        block.getChartBlock()\r\n            .insert('circle', \".\" + dot_1.Dot.dotClass)\r\n            .attr('class', 'dot-edging-external')\r\n            .attr('cx', attrs.cx)\r\n            .attr('cy', attrs.cy)\r\n            .attr('r', 15.5)\r\n            .style('opacity', 0.2)\r\n            .style('fill', color)\r\n            .style('pointer-events', 'none');\r\n    };\r\n    Tooltip.removeDotsEdging = function (block) {\r\n        block.getChartBlock()\r\n            .selectAll('.dot-edging-external, .dot-edging-internal')\r\n            .remove();\r\n    };\r\n    Tooltip.renderBarHighlighter = function (block, barAttrs) {\r\n        var barHighlighter = block.getChartBlock()\r\n            .append('rect')\r\n            .attr('class', 'bar-highlighter')\r\n            .attr('x', barAttrs.x)\r\n            .attr('y', barAttrs.y)\r\n            .attr('width', barAttrs.width)\r\n            .attr('height', barAttrs.height)\r\n            .style('fill', '#8a8a8a')\r\n            .style('pointer-events', 'none')\r\n            .style('opacity', 0.2)\r\n            .lower();\r\n        return barHighlighter;\r\n    };\r\n    Tooltip.tooltipWrapperClass = 'tooltip-wrapper';\r\n    Tooltip.tooltipContentClass = 'tooltip-content';\r\n    Tooltip.tooltipBlockClass = 'tooltip-block';\r\n    Tooltip.tooltipArrowClass = 'tooltip-arrow';\r\n    return Tooltip;\r\n}());\r\nexports.Tooltip = Tooltip;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltip.ts?");

/***/ }),

/***/ "./src/engine/features/tolltip/tooltipHelper.ts":
/*!******************************************************!*\
  !*** ./src/engine/features/tolltip/tooltipHelper.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TooltipHelper = exports.ARROW_DEFAULT_POSITION = exports.ARROW_SIZE = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar valueFormatter_1 = __webpack_require__(/*! ../../valueFormatter */ \"./src/engine/valueFormatter.ts\");\r\nvar dot_1 = __webpack_require__(/*! ../lineDots/dot */ \"./src/engine/features/lineDots/dot.ts\");\r\nexports.ARROW_SIZE = 20;\r\nexports.ARROW_DEFAULT_POSITION = 9;\r\nvar TOOLTIP_ARROW_PADDING_X = exports.ARROW_DEFAULT_POSITION - (exports.ARROW_SIZE * Math.sqrt(2) - exports.ARROW_SIZE) / 2 + 14;\r\nvar TOOLTIP_ARROW_PADDING_Y = 13;\r\nvar TooltipHelper = /** @class */ (function () {\r\n    function TooltipHelper() {\r\n    }\r\n    TooltipHelper.getMultyTooltipHtmlFor2DChart = function (chart, data, keyValue) {\r\n        var _this = this;\r\n        var text = '';\r\n        chart.data.valueFields.forEach(function (field, index) {\r\n            text += _this.getTooltipHtml(chart, data, keyValue, field, chart.style.elementColors[index % chart.style.elementColors.length].toString());\r\n        });\r\n        return text;\r\n    };\r\n    TooltipHelper.getTooltipHtmlFor2DChart = function (chart, data, keyValue, index) {\r\n        return this.getTooltipHtml(chart, data, keyValue, chart.data.valueFields[index], chart.style.elementColors[index % chart.style.elementColors.length].toString());\r\n    };\r\n    TooltipHelper.getTooltipHtmlForPolarChart = function (chart, data, keyValue, markColor) {\r\n        return this.getTooltipHtml(chart, data, keyValue, chart.data.valueField, markColor);\r\n    };\r\n    TooltipHelper.getTooltipHtmlForIntervalChart = function (chart, data, keyValue, markColor) {\r\n        return this.getTooltipHtml(chart, data, keyValue, chart.data.valueField1, markColor);\r\n    };\r\n    TooltipHelper.getTooltipCoordinate = function (pointer) {\r\n        var coordinate = {\r\n            left: null,\r\n            top: null,\r\n            right: null,\r\n            bottom: null\r\n        };\r\n        coordinate.left = pointer[0] + 'px';\r\n        coordinate.top = pointer[1] + 'px';\r\n        return coordinate;\r\n    };\r\n    TooltipHelper.getTooltipBlockCoordinateByRect = function (element, tooltipBlock, blockSize, tooltipArrow, chartOrientation) {\r\n        var blockPositionRatio = chartOrientation === 'vertical' ? 2 : 1; // If chart has horizontal orientation, block takes coordinte of end of bar, if chart vertical, block takes center of bar.\r\n        var coordinateTuple = [parseFloat(element.attr('x')) + parseFloat(element.attr('width')) / blockPositionRatio, parseFloat(element.attr('y'))];\r\n        return this.getRecalcedCoordinateByArrow(coordinateTuple, tooltipBlock, blockSize, tooltipArrow);\r\n    };\r\n    TooltipHelper.getTooltipBlockCoordinateByDot = function (element, tooltipBlock, blockSize, tooltipArrow) {\r\n        var coordinateTuple = [parseFloat(element.attr('cx')), parseFloat(element.attr('cy'))];\r\n        return this.getRecalcedCoordinateByArrow(coordinateTuple, tooltipBlock, blockSize, tooltipArrow);\r\n    };\r\n    TooltipHelper.getRecalcedCoordinateByArrow = function (coordinate, tooltipBlock, blockSize, tooltipArrow, translateX, translateY) {\r\n        if (translateX === void 0) { translateX = 0; }\r\n        if (translateY === void 0) { translateY = 0; }\r\n        var tooltipBlockNode = tooltipBlock.node();\r\n        var horizontalPad = this.getHorizontalPad(coordinate[0], tooltipBlockNode, blockSize, translateX);\r\n        var verticalPad = this.getVerticalPad(coordinate[1], tooltipBlockNode, translateY);\r\n        this.setTooltipArrowCoordinate(tooltipArrow, this.getTooltipArrowPadding(tooltipBlockNode, horizontalPad));\r\n        return [coordinate[0] - TOOLTIP_ARROW_PADDING_X - horizontalPad,\r\n            coordinate[1] - TOOLTIP_ARROW_PADDING_Y - tooltipBlockNode.getBoundingClientRect().height - verticalPad];\r\n    };\r\n    TooltipHelper.getDotEdgingAttrs = function (element) {\r\n        return {\r\n            cx: parseFloat(element.attr('cx')),\r\n            cy: parseFloat(element.attr('cy'))\r\n        };\r\n    };\r\n    TooltipHelper.getKeyForTooltip = function (row, keyFieldName, isSegmented) {\r\n        return isSegmented ? row.data[keyFieldName] : row[keyFieldName];\r\n    };\r\n    TooltipHelper.getFilteredElements = function (elements, keyFieldName, keyValue, isSegmented) {\r\n        if (isSegmented)\r\n            return elements.filter(function (d) { return d.data[keyFieldName] !== keyValue; });\r\n        return elements.filter(function (d) { return d[keyFieldName] !== keyValue; });\r\n    };\r\n    TooltipHelper.getElementIndex = function (elemets, dot, keyValue, keyName, isSegmented) {\r\n        var index = -1;\r\n        var filtered = isSegmented ? elemets.filter(function (d) { return d.data[keyName] === keyValue; }) : elemets.filter(function (d) { return d[keyName] === keyValue; });\r\n        filtered.each(function (d, i) {\r\n            if (d3.select(this).node() === d3.select(dot).node()) {\r\n                index = i;\r\n            }\r\n        });\r\n        return index;\r\n    };\r\n    TooltipHelper.getOtherChartsElements = function (block, chartIndex, chartsClasses) {\r\n        var classes = '';\r\n        chartsClasses.forEach(function (cssClasses, index) {\r\n            if (chartIndex !== index) {\r\n                if (classes !== '')\r\n                    classes += ', ';\r\n                classes += helper_1.Helper.getCssClassesLine(cssClasses);\r\n            }\r\n        });\r\n        if (classes === '')\r\n            return null;\r\n        return block.getChartBlock()\r\n            .selectAll(classes);\r\n    };\r\n    TooltipHelper.setElementsSemiOpacity = function (elements) {\r\n        if (elements)\r\n            elements.style('opacity', 0.3);\r\n    };\r\n    TooltipHelper.setElementsFullOpacity = function (elements) {\r\n        if (elements)\r\n            elements.style('opacity', 1);\r\n    };\r\n    TooltipHelper.setOtherChartsElementsDefaultOpacity = function (elements, chartsStyleSettings) {\r\n        if (!elements)\r\n            return;\r\n        var thisClass = this;\r\n        elements.each(function () {\r\n            var indexOfChart = thisClass.findChartIndexOfElement(d3.select(this), chartsStyleSettings);\r\n            if (!d3.select(this).classed(dot_1.Dot.dotClass) && !d3.select(this).classed(dot_1.Dot.innerDotClass))\r\n                d3.select(this).style('opacity', chartsStyleSettings[indexOfChart].opacity);\r\n            else\r\n                d3.select(this).style('opacity', 1);\r\n        });\r\n    };\r\n    TooltipHelper.getBarHighlighterAttrs = function (bar, chartOrientation, blockSize, margin) {\r\n        var pad = 3;\r\n        if (chartOrientation === 'vertical')\r\n            return {\r\n                x: helper_1.Helper.getSelectionNumericAttr(bar, 'x') - pad,\r\n                y: margin.top,\r\n                width: helper_1.Helper.getSelectionNumericAttr(bar, 'width') + pad * 2,\r\n                height: blockSize.height - margin.top - margin.bottom\r\n            };\r\n        return {\r\n            x: margin.left,\r\n            y: helper_1.Helper.getSelectionNumericAttr(bar, 'y') - pad,\r\n            width: blockSize.width - margin.left - margin.right,\r\n            height: helper_1.Helper.getSelectionNumericAttr(bar, 'height') + pad * 2\r\n        };\r\n    };\r\n    TooltipHelper.getChartStyleSettings = function (chart) {\r\n        return {\r\n            cssClasses: chart.cssClasses,\r\n            opacity: chart.style.opacity\r\n        };\r\n    };\r\n    TooltipHelper.findChartIndexOfElement = function (element, chartStyleSettings) {\r\n        var index = null;\r\n        chartStyleSettings.forEach(function (styleSettings, i) {\r\n            if (element.classed(styleSettings.cssClasses.join(' '))) {\r\n                index = i;\r\n            }\r\n        });\r\n        return index;\r\n    };\r\n    TooltipHelper.getTooltipHtml = function (chart, data, keyValue, valueField, markColor) {\r\n        var text = \"<div class=\\\"tooltip-group\\\"><div class=\\\"tooltip-color\\\"><span class=\\\"tooltip-circle\\\" style=\\\"background-color: \" + markColor + \";\\\"></span></div>\";\r\n        text += \"<div class=\\\"tooltip-texts\\\">\";\r\n        text += \"<div class=\\\"tp-text-item\\\" style=\\\"white-space: nowrap\\\">\" + this.getTooltipItemText(chart, data, keyValue, valueField) + \"</div>\";\r\n        text += '</div></div>';\r\n        return text;\r\n    };\r\n    TooltipHelper.getTooltipItemText = function (chart, data, keyValue, valueField) {\r\n        var row = data[chart.data.dataSource].find(function (d) { return d[chart.data.keyField.name] === keyValue; });\r\n        return row[chart.data.keyField.name] + \" - \" + valueFormatter_1.ValueFormatter.formatValue(valueField.format, row[valueField.name]);\r\n    };\r\n    TooltipHelper.getHorizontalPad = function (coordinateX, tooltipBlockNode, blockSize, translateX) {\r\n        var pad = 0;\r\n        if (tooltipBlockNode.getBoundingClientRect().width + coordinateX - TOOLTIP_ARROW_PADDING_X + translateX > blockSize.width)\r\n            pad = tooltipBlockNode.getBoundingClientRect().width + coordinateX - TOOLTIP_ARROW_PADDING_X + translateX - blockSize.width;\r\n        return pad;\r\n    };\r\n    TooltipHelper.getVerticalPad = function (coordinateY, tooltipBlockNode, translateY) {\r\n        var pad = 0;\r\n        if (coordinateY - TOOLTIP_ARROW_PADDING_Y - tooltipBlockNode.getBoundingClientRect().height + translateY < -tooltipBlockNode.getBoundingClientRect().height - TOOLTIP_ARROW_PADDING_Y)\r\n            pad = coordinateY;\r\n        return pad; // return zero or sub zero\r\n    };\r\n    TooltipHelper.setTooltipArrowCoordinate = function (tooltipArrow, horizontalPad) {\r\n        if (horizontalPad !== 0)\r\n            tooltipArrow.style('left', exports.ARROW_DEFAULT_POSITION + Math.floor(horizontalPad) + \"px\");\r\n        else\r\n            tooltipArrow.style('left', exports.ARROW_DEFAULT_POSITION + \"px\");\r\n    };\r\n    TooltipHelper.getTooltipArrowPadding = function (tooltipBlockNode, horizontalPad) {\r\n        return horizontalPad > tooltipBlockNode.getBoundingClientRect().width\r\n            ? tooltipBlockNode.getBoundingClientRect().width - exports.ARROW_DEFAULT_POSITION - 20 * Math.sqrt(2)\r\n            : horizontalPad; // If tooltip arrow has coordinate outside svg, it take X position in end of tooltip block\r\n    };\r\n    return TooltipHelper;\r\n}());\r\nexports.TooltipHelper = TooltipHelper;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/features/tolltip/tooltipHelper.ts?");

/***/ }),

/***/ "./src/engine/helper.ts":
/*!******************************!*\
  !*** ./src/engine/helper.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Helper = void 0;\r\nvar Helper = /** @class */ (function () {\r\n    function Helper() {\r\n    }\r\n    Helper.setCssClasses = function (elem, cssClasses) {\r\n        cssClasses.forEach(function (cssClass) {\r\n            elem.classed(cssClass, true);\r\n        });\r\n    };\r\n    Helper.getCssClassesLine = function (cssClasses) {\r\n        return '.' + cssClasses.join('.');\r\n    };\r\n    Helper.setChartStyle = function (elements, chartStyle, fieldIndex, styleType) {\r\n        this.setChartElementColor(elements, chartStyle.elementColors, fieldIndex, styleType);\r\n        this.setChartOpacity(elements, chartStyle.opacity);\r\n    };\r\n    Helper.setChartElementColor = function (elements, colorPalette, fieldIndex, styleType) {\r\n        elements.style(styleType, colorPalette[fieldIndex % colorPalette.length].toString());\r\n    };\r\n    Helper.cropLabels = function (labelBlocks, maxWidth) {\r\n        labelBlocks.nodes().forEach(function (node) {\r\n            if (node.getBBox().width > maxWidth) {\r\n                var text = node.textContent;\r\n                var textLength = text.length;\r\n                while (node.getBBox().width > maxWidth && textLength > 0) {\r\n                    node.textContent = text.substring(0, --textLength) + '...';\r\n                }\r\n                if (textLength === 0)\r\n                    node.textContent = '';\r\n            }\r\n        });\r\n    };\r\n    Helper.getCssClassesArray = function (cssClass) {\r\n        return cssClass.split(' ');\r\n    };\r\n    Helper.getTranslateNumbers = function (transformValue) {\r\n        if (!transformValue)\r\n            return [0, 0];\r\n        var translateNumbers = transformValue.substring(10, transformValue.length - 1).split(', ');\r\n        var translateX = parseFloat(translateNumbers[0]);\r\n        var translateY = parseFloat(translateNumbers[1]);\r\n        return [translateX, translateY];\r\n    };\r\n    Helper.getSumOfNumbers = function (numbers) {\r\n        var sum = 0;\r\n        numbers.forEach(function (num) { return sum += num; });\r\n        return sum;\r\n    };\r\n    Helper.getCssPropertyValue = function (node, propertyName) {\r\n        return window.getComputedStyle(node).getPropertyValue(propertyName);\r\n    };\r\n    Helper.getPXValueFromString = function (propertyValue) {\r\n        return parseFloat(propertyValue);\r\n    };\r\n    Helper.getSelectionNumericAttr = function (selection, attrName) {\r\n        return parseFloat(selection.attr(attrName));\r\n    };\r\n    Helper.getCssClassesWithElementIndex = function (cssClasses, index) {\r\n        return cssClasses.concat([\"chart-element-\" + index]);\r\n    };\r\n    Helper.setChartOpacity = function (elements, opacity) {\r\n        elements.attr('opacity', opacity);\r\n    };\r\n    return Helper;\r\n}());\r\nexports.Helper = Helper;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/helper.ts?");

/***/ }),

/***/ "./src/engine/intervalNotation/gantt.ts":
/*!**********************************************!*\
  !*** ./src/engine/intervalNotation/gantt.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Gantt = void 0;\r\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar Gantt = /** @class */ (function () {\r\n    function Gantt() {\r\n    }\r\n    Gantt.render = function (block, data, scales, margin, keyAxisOrient, chart, barSettings) {\r\n        var ganttItems = block.getChartBlock()\r\n            .selectAll(\".\" + this.ganttItemClass)\r\n            .data(data)\r\n            .enter()\r\n            .append('rect')\r\n            .attr('class', this.ganttItemClass)\r\n            .style('clip-path', \"url(\" + block.getClipPathId() + \")\");\r\n        var itemsAttrs = this.getItemsAttrsByKeyOrient(keyAxisOrient, scales, margin, chart.data.keyField.name, chart.data.valueField1.name, chart.data.valueField2.name, barSettings);\r\n        this.fillItemsAttrs(ganttItems, itemsAttrs);\r\n        helper_1.Helper.setCssClasses(ganttItems, chart.cssClasses);\r\n        helper_1.Helper.setChartStyle(ganttItems, chart.style, 0, 'fill');\r\n    };\r\n    Gantt.fillItemsAttrs = function (ganttItems, attrs) {\r\n        ganttItems\r\n            .attr('x', function (d) { return attrs.x(d); })\r\n            .attr('y', function (d) { return attrs.y(d); })\r\n            .attr('width', function (d) { return attrs.width(d); })\r\n            .attr('height', function (d) { return attrs.height(d); });\r\n    };\r\n    Gantt.getItemsAttrsByKeyOrient = function (axisOrient, scales, margin, keyField, valueField1, valueField2, barSettings) {\r\n        var attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        var itemSize = scale_1.Scale.getScaleWidth(scales.scaleKey) > barSettings.maxBarWidth\r\n            ? barSettings.maxBarWidth\r\n            : scale_1.Scale.getScaleWidth(scales.scaleKey);\r\n        var sizeDiff = (scale_1.Scale.getScaleWidth(scales.scaleKey) - itemSize) / 2;\r\n        if (axisOrient === 'top' || axisOrient === 'bottom') {\r\n            attrs.x = function (d) { return scales.scaleKey(d[keyField]) + margin.left + sizeDiff; };\r\n            attrs.width = function (d) { return itemSize; };\r\n        }\r\n        if (axisOrient === 'left' || axisOrient === 'right') {\r\n            attrs.y = function (d) { return scales.scaleKey(d[keyField]) + margin.top + sizeDiff; };\r\n            attrs.height = function (d) { return itemSize; };\r\n        }\r\n        if (axisOrient === 'top') {\r\n            attrs.y = function (d) { return scales.scaleValue(d[valueField1]) + margin.top; };\r\n            attrs.height = function (d) { return scales.scaleValue(d[valueField2]) - scales.scaleValue(d[valueField1]); };\r\n        }\r\n        else if (axisOrient === 'bottom') {\r\n            attrs.y = function (d) { return scales.scaleValue(d[valueField2]) + margin.top; };\r\n            attrs.height = function (d) { return scales.scaleValue(d[valueField1]) - scales.scaleValue(d[valueField2]); };\r\n        }\r\n        else if (axisOrient === 'left') {\r\n            attrs.x = function (d) { return scales.scaleValue(d[valueField1]) + margin.left; };\r\n            attrs.width = function (d) { return scales.scaleValue(d[valueField2]) - scales.scaleValue(d[valueField1]); };\r\n        }\r\n        else if (axisOrient === 'right') {\r\n            attrs.x = function (d) { return scales.scaleValue(d[valueField2]) + margin.left; };\r\n            attrs.width = function (d) { return scales.scaleValue(d[valueField1]) - scales.scaleValue(d[valueField2]); };\r\n        }\r\n        return attrs;\r\n    };\r\n    Gantt.ganttItemClass = 'gantt-item';\r\n    return Gantt;\r\n}());\r\nexports.Gantt = Gantt;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/intervalNotation/gantt.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/aggregator.ts":
/*!************************************************!*\
  !*** ./src/engine/polarNotation/aggregator.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Aggregator = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar Aggregator = /** @class */ (function () {\r\n    function Aggregator() {\r\n    }\r\n    Aggregator.render = function (block, data, valueField, innerRadius, translate, fontSize) {\r\n        var aggregator = {\r\n            name: 'Сумма',\r\n            value: d3.sum(data.map(function (d) { return d[valueField]; }))\r\n        };\r\n        this.renderAggregatorText(block, innerRadius, aggregator, translate, fontSize);\r\n    };\r\n    Aggregator.renderAggregatorText = function (block, innerRadius, aggregator, translate, fontSize) {\r\n        if (innerRadius > 50) {\r\n            var aggregatorObject = this.renderAggregatorObject(block, innerRadius, translate);\r\n            var wrapper = this.renderAggregatorWrapper(aggregatorObject);\r\n            wrapper\r\n                .append('div')\r\n                .attr('class', 'aggregator-value')\r\n                .style('text-align', 'center')\r\n                .style('font-size', fontSize + \"px\")\r\n                .text(aggregator.value);\r\n            wrapper\r\n                .append('div')\r\n                .attr('class', 'aggregator-name')\r\n                .style('text-align', 'center')\r\n                .style('font-size', '18px')\r\n                .text(aggregator.name);\r\n        }\r\n    };\r\n    Aggregator.renderAggregatorObject = function (block, innerRadius, translate) {\r\n        return block.getSvg()\r\n            .append('foreignObject')\r\n            .attr('class', 'aggregator-object')\r\n            .attr('transform-origin', 'center')\r\n            .attr('width', innerRadius * 2)\r\n            .attr('height', innerRadius * 2)\r\n            .attr('transform', \"translate(\" + (translate.x - innerRadius) + \", \" + (translate.y - innerRadius) + \")\")\r\n            .style('pointer-events', \"none\");\r\n    };\r\n    Aggregator.renderAggregatorWrapper = function (aggregatorObject) {\r\n        return aggregatorObject\r\n            .append('xhtml:div')\r\n            .style('width', '100%')\r\n            .style('height', '100%')\r\n            .style('border-radius', '50%')\r\n            .style('display', 'flex')\r\n            .style('flex-direction', 'column')\r\n            .style('justify-content', 'center')\r\n            .style('align-items', 'center');\r\n    };\r\n    return Aggregator;\r\n}());\r\nexports.Aggregator = Aggregator;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/aggregator.ts?");

/***/ }),

/***/ "./src/engine/polarNotation/donut.ts":
/*!*******************************************!*\
  !*** ./src/engine/polarNotation/donut.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Donut = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../helper */ \"./src/engine/helper.ts\");\r\nvar aggregator_1 = __webpack_require__(/*! ./aggregator */ \"./src/engine/polarNotation/aggregator.ts\");\r\nvar Donut = /** @class */ (function () {\r\n    function Donut() {\r\n    }\r\n    Donut.render = function (block, data, margin, chart, blockSize, donutSettings) {\r\n        var outerRadius = this.getOuterRadius(margin, blockSize);\r\n        var thickness = this.getThickness(donutSettings, blockSize, margin);\r\n        var innerRadius = this.getInnerRadius(outerRadius, thickness);\r\n        var arc = this.getArcGenerator(outerRadius, innerRadius);\r\n        var pie = this.getPieGenerator(chart.data.valueField.name, donutSettings.padAngle);\r\n        var translate = this.getTranslate(margin, blockSize);\r\n        var donutBlock = block.getSvg()\r\n            .append('g')\r\n            .attr('class', this.donutBlockClass)\r\n            .attr('x', translate.x)\r\n            .attr('y', translate.y)\r\n            .attr('transform', \"translate(\" + translate.x + \", \" + translate.y + \")\");\r\n        var items = donutBlock\r\n            .selectAll(\".\" + this.arcItemClass)\r\n            .data(pie(data))\r\n            .enter()\r\n            .append('g')\r\n            .attr('class', this.arcItemClass);\r\n        var arcs = items\r\n            .append('path')\r\n            .attr('d', arc);\r\n        helper_1.Helper.setCssClasses(arcs, chart.cssClasses);\r\n        this.setElementsColor(items, chart.style.elementColors);\r\n        aggregator_1.Aggregator.render(block, data, chart.data.valueField.name, innerRadius, translate, thickness);\r\n    };\r\n    Donut.getAllArcs = function (block) {\r\n        return block.getSvg()\r\n            .selectAll(\".\" + this.arcItemClass);\r\n    };\r\n    Donut.getThickness = function (donutSettings, blockSize, margin) {\r\n        if (Math.min(blockSize.width - margin.left - margin.right, blockSize.height - margin.bottom - margin.top) > 400)\r\n            return donutSettings.maxThickness;\r\n        return donutSettings.minThickness;\r\n    };\r\n    Donut.getArcCentroid = function (blockSize, margin, dataItem, donutThickness) {\r\n        var outerRadius = this.getOuterRadius(margin, blockSize);\r\n        var arc = this.getArcGenerator(outerRadius, outerRadius - donutThickness);\r\n        return arc.centroid(dataItem);\r\n    };\r\n    Donut.getInnerRadius = function (outerRadius, thickness) {\r\n        return outerRadius - thickness;\r\n    };\r\n    Donut.getTranslate = function (margin, blockSize) {\r\n        return {\r\n            x: (blockSize.width - margin.left - margin.right) / 2 + margin.left,\r\n            y: (blockSize.height - margin.top - margin.bottom) / 2 + margin.top\r\n        };\r\n    };\r\n    Donut.getOuterRadius = function (margin, blockSize) {\r\n        return Math.min(blockSize.width - margin.left - margin.right, blockSize.height - margin.top - margin.bottom) / 2;\r\n    };\r\n    Donut.getArcGenerator = function (outerRadius, innerRadius) {\r\n        return d3.arc()\r\n            .innerRadius(innerRadius)\r\n            .outerRadius(outerRadius);\r\n    };\r\n    Donut.getPieGenerator = function (valueField, padAngle) {\r\n        return d3.pie()\r\n            .padAngle(padAngle)\r\n            .sort(null)\r\n            .value(function (d) { return d[valueField]; });\r\n    };\r\n    Donut.setElementsColor = function (arcItems, colorPalette) {\r\n        arcItems\r\n            .select('path')\r\n            .style('fill', function (d, i) { return colorPalette[i % colorPalette.length].toString(); });\r\n    };\r\n    Donut.donutBlockClass = 'donut-block';\r\n    Donut.arcItemClass = 'arc';\r\n    return Donut;\r\n}());\r\nexports.Donut = Donut;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/polarNotation/donut.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/area/area.ts":
/*!********************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/area/area.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Area = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar dot_1 = __webpack_require__(/*! ../../features/lineDots/dot */ \"./src/engine/features/lineDots/dot.ts\");\r\nvar Area = /** @class */ (function () {\r\n    function Area() {\r\n    }\r\n    Area.render = function (block, scales, data, margin, keyAxisOrient, chart, blockSize, isSegmented) {\r\n        if (isSegmented)\r\n            this.renderSegmented(block, scales, data, margin, keyAxisOrient, chart, blockSize);\r\n        else\r\n            this.renderGrouped(block, scales, data, margin, keyAxisOrient, chart, blockSize);\r\n    };\r\n    Area.updateAreaChartByValueAxis = function (block, scales, data, margin, chart, keyAxisOrient, blockSize, isSegmented) {\r\n        var _this = this;\r\n        if (isSegmented) {\r\n            var area_1 = this.getSegmentedAreaGenerator(keyAxisOrient, scales, margin, chart.data.keyField.name);\r\n            var areas = block.getChartBlock()\r\n                .selectAll(\"path.\" + this.areaChartClass + helper_1.Helper.getCssClassesLine(chart.cssClasses));\r\n            areas\r\n                .transition()\r\n                .duration(1000)\r\n                .attr('d', function (d) { return area_1(d); });\r\n            areas.each(function (d, i) {\r\n                dot_1.Dot.updateDotsCoordinateByValueAxis(block, d, keyAxisOrient, scales, margin, chart.data.keyField.name, '1', chart.cssClasses, i, isSegmented);\r\n            });\r\n        }\r\n        else {\r\n            chart.data.valueFields.forEach(function (field, index) {\r\n                var area = _this.getGroupedAreaGenerator(keyAxisOrient, scales, margin, chart.data.keyField.name, field.name, blockSize);\r\n                block.getChartBlock()\r\n                    .select(\".\" + _this.areaChartClass + helper_1.Helper.getCssClassesLine(chart.cssClasses) + \".chart-element-\" + index)\r\n                    .transition()\r\n                    .duration(1000)\r\n                    .attr('d', area(data));\r\n                dot_1.Dot.updateDotsCoordinateByValueAxis(block, data, keyAxisOrient, scales, margin, chart.data.keyField.name, field.name, chart.cssClasses, index, isSegmented);\r\n            });\r\n        }\r\n    };\r\n    Area.renderGrouped = function (block, scales, data, margin, keyAxisOrient, chart, blockSize) {\r\n        var _this = this;\r\n        chart.data.valueFields.forEach(function (field, index) {\r\n            var area = _this.getGroupedAreaGenerator(keyAxisOrient, scales, margin, chart.data.keyField.name, field.name, blockSize);\r\n            var path = block.getChartBlock()\r\n                .append('path')\r\n                .attr('d', area(data))\r\n                .attr('class', _this.areaChartClass)\r\n                .style('clip-path', \"url(\" + block.getClipPathId() + \")\")\r\n                .style('pointer-events', 'none');\r\n            helper_1.Helper.setCssClasses(path, helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, index));\r\n            helper_1.Helper.setChartStyle(path, chart.style, index, 'fill');\r\n            dot_1.Dot.render(block, data, keyAxisOrient, scales, margin, chart.data.keyField.name, field.name, chart.cssClasses, index, chart.style.elementColors, blockSize, false);\r\n        });\r\n    };\r\n    Area.renderSegmented = function (block, scales, data, margin, keyAxisOrient, chart, blockSize) {\r\n        var keys = chart.data.valueFields.map(function (field) { return field.name; });\r\n        var stackedData = d3.stack().keys(keys)(data);\r\n        var area = this.getSegmentedAreaGenerator(keyAxisOrient, scales, margin, chart.data.keyField.name);\r\n        var areas = block.getChartBlock()\r\n            .selectAll('.area')\r\n            .data(stackedData)\r\n            .enter()\r\n            .append('path')\r\n            .attr('d', function (d) { return area(d); })\r\n            .attr('class', this.areaChartClass)\r\n            .style('clip-path', \"url(\" + block.getClipPathId() + \")\")\r\n            .style('pointer-events', 'none');\r\n        areas.each(function (d, i) {\r\n            helper_1.Helper.setCssClasses(d3.select(this), helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, i));\r\n        });\r\n        this.setSegmentColor(areas, chart.style.elementColors);\r\n        stackedData.forEach(function (sd, index) {\r\n            dot_1.Dot.render(block, sd, keyAxisOrient, scales, margin, chart.data.keyField.name, '1', chart.cssClasses, index, chart.style.elementColors, blockSize, true);\r\n        });\r\n    };\r\n    Area.getGroupedAreaGenerator = function (keyAxisOrient, scales, margin, keyFieldName, valueFieldName, blockSize) {\r\n        var _this = this;\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top')\r\n            return d3.area()\r\n                .x(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d[keyFieldName]) + margin.left; })\r\n                .y0(function (d) { return _this.getZeroCoordinate(keyAxisOrient, margin, blockSize); })\r\n                .y1(function (d) { return scales.scaleValue(d[valueFieldName]) + margin.top; });\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right')\r\n            return d3.area()\r\n                .x0(function (d) { return _this.getZeroCoordinate(keyAxisOrient, margin, blockSize); })\r\n                .x1(function (d) { return scales.scaleValue(d[valueFieldName]) + margin.left; })\r\n                .y(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d[keyFieldName]) + margin.top; });\r\n    };\r\n    Area.getSegmentedAreaGenerator = function (keyAxisOrient, scales, margin, keyField) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return d3.area()\r\n                .x(function (d) { return scales.scaleKey(d.data[keyField]) + margin.left; })\r\n                .y0(function (d) { return scales.scaleValue(d[0]) + margin.top; })\r\n                .y1(function (d) { return scales.scaleValue(d[1]) + margin.top; });\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return d3.area()\r\n                .x0(function (d) { return scales.scaleValue(d[0]) + margin.left; })\r\n                .x1(function (d) { return scales.scaleValue(d[1]) + margin.left; })\r\n                .y(function (d) { return scales.scaleKey(d.data[keyField]) + margin.top; });\r\n        }\r\n    };\r\n    Area.getZeroCoordinate = function (axisOrient, margin, blockSize) {\r\n        if (axisOrient === 'bottom')\r\n            return blockSize.height - margin.bottom;\r\n        if (axisOrient === 'top')\r\n            return margin.top;\r\n        if (axisOrient === 'left')\r\n            return margin.left;\r\n        if (axisOrient === 'right')\r\n            return blockSize.width - margin.right;\r\n    };\r\n    Area.setSegmentColor = function (segments, colorPalette) {\r\n        segments.style('fill', function (d, i) { return colorPalette[i % colorPalette.length].toString(); });\r\n    };\r\n    Area.areaChartClass = 'area';\r\n    return Area;\r\n}());\r\nexports.Area = Area;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/area/area.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/bar/bar.ts":
/*!******************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/bar/bar.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Bar = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar valueFormatter_1 = __webpack_require__(/*! ../../valueFormatter */ \"./src/engine/valueFormatter.ts\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar embeddedLabels_1 = __webpack_require__(/*! ../../features/embeddedLabels/embeddedLabels */ \"./src/engine/features/embeddedLabels/embeddedLabels.ts\");\r\nvar embeddedLabelsHelper_1 = __webpack_require__(/*! ../../features/embeddedLabels/embeddedLabelsHelper */ \"./src/engine/features/embeddedLabels/embeddedLabelsHelper.ts\");\r\nvar Bar = /** @class */ (function () {\r\n    function Bar() {\r\n    }\r\n    Bar.render = function (block, scales, data, margin, keyAxisOrient, chart, blockSize, barSettings, isSegmented) {\r\n        if (isSegmented)\r\n            this.renderSegmented(block, scales, data, margin, keyAxisOrient, chart, blockSize, barSettings);\r\n        else\r\n            this.renderGrouped(block, scales, data, margin, keyAxisOrient, chart, blockSize, barSettings);\r\n    };\r\n    Bar.updateBarChartByValueAxis = function (block, scales, margin, keyAxisOrient, chart, blockSize, isSegmented) {\r\n        var _this = this;\r\n        if (isSegmented) {\r\n            var bars = block.getChartBlock()\r\n                .selectAll(\".\" + this.barItemClass + helper_1.Helper.getCssClassesLine(chart.cssClasses));\r\n            this.fillStackedBarAttrsByKeyOrientWithTransition(bars, keyAxisOrient, scales.scaleValue, margin, blockSize, 1000);\r\n        }\r\n        else {\r\n            chart.data.valueFields.forEach(function (field, index) {\r\n                var bars = block.getChartBlock()\r\n                    .selectAll(\".\" + _this.barItemClass + helper_1.Helper.getCssClassesLine(chart.cssClasses) + \".chart-element-\" + index);\r\n                _this.fillBarAttrsByKeyOrientWithTransition(bars, keyAxisOrient, scales.scaleValue, margin, field.name, blockSize, 1000);\r\n            });\r\n        }\r\n    };\r\n    Bar.getAllBarItems = function (block) {\r\n        return block.getSvg().selectAll(\"rect.\" + this.barItemClass);\r\n    };\r\n    Bar.renderGrouped = function (block, scales, data, margin, keyAxisOrient, chart, blockSize, barSettings) {\r\n        var _this = this;\r\n        this.renderBarGroups(block, data);\r\n        chart.data.valueFields.forEach(function (field, index) {\r\n            var bars = block.getChartBlock()\r\n                .selectAll('.bar-group')\r\n                .data(data)\r\n                .append('rect')\r\n                .attr('class', _this.barItemClass)\r\n                .style('clip-path', \"url(\" + block.getClipPathId() + \")\");\r\n            var barAttrs = _this.getGroupedBarAttrsByKeyOrient(block, keyAxisOrient, scales, margin, chart.data.keyField.name, field.name, blockSize, chart.data.valueFields.length, barSettings);\r\n            _this.fillBarAttrsByKeyOrient(bars, barAttrs);\r\n            helper_1.Helper.setCssClasses(bars, helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, index));\r\n            helper_1.Helper.setChartStyle(bars, chart.style, index, 'fill');\r\n            if (chart.embeddedLabels !== 'none')\r\n                embeddedLabels_1.EmbeddedLabels.render(block, bars, embeddedLabelsHelper_1.EmbeddedLabelsHelper.getLabelField(chart.embeddedLabels, chart.data, index), chart.embeddedLabels, keyAxisOrient, blockSize, margin);\r\n        });\r\n    };\r\n    Bar.renderSegmented = function (block, scales, data, margin, keyAxisOrient, chart, blockSize, barSettings) {\r\n        var keys = chart.data.valueFields.map(function (field) { return field.name; });\r\n        var stackedData = d3.stack().keys(keys)(data);\r\n        var groups = block.getChartBlock()\r\n            .selectAll('g')\r\n            .data(stackedData)\r\n            .enter()\r\n            .append('g');\r\n        var bars = groups\r\n            .selectAll('rect')\r\n            .data(function (d) { return d; })\r\n            .enter()\r\n            .append('rect')\r\n            .attr('class', this.barItemClass)\r\n            .style('clip-path', \"url(\" + block.getClipPathId() + \")\");\r\n        var barAttrs = this.getStackedBarAttrByKeyOrient(keyAxisOrient, scales, margin, chart.data.keyField.name, blockSize, barSettings);\r\n        bars\r\n            .attr('x', barAttrs.x)\r\n            .attr('y', barAttrs.y)\r\n            .attr('width', barAttrs.width)\r\n            .attr('height', barAttrs.height);\r\n        groups.each(function (d, i) {\r\n            helper_1.Helper.setCssClasses(d3.select(this).selectAll('rect'), helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, i));\r\n        });\r\n        this.setSegmentColor(groups, chart.style.elementColors);\r\n    };\r\n    Bar.renderBarGroups = function (block, data) {\r\n        var groups = block.getChartBlock()\r\n            .selectAll('.bar-group');\r\n        if (groups.empty())\r\n            groups = block.getChartBlock()\r\n                .selectAll('.bar-group')\r\n                .data(data)\r\n                .enter()\r\n                .append('g')\r\n                .attr('class', 'bar-group');\r\n    };\r\n    Bar.getGroupedBarAttrsByKeyOrient = function (block, axisOrient, scales, margin, keyField, valueField, blockSize, barsAmount, barSettings) {\r\n        var chartIndex = block.getSvg().select('.bar-group').selectAll(\".\" + this.barItemClass).size() - 1;\r\n        var barDistance = barSettings.barDistance;\r\n        var barStep = (scale_1.Scale.getScaleWidth(scales.scaleKey) - barDistance * (barsAmount - 1)) / barsAmount; // Space for one bar\r\n        var barSize = barStep > barSettings.maxBarWidth ? barSettings.maxBarWidth : barStep;\r\n        var barDiff = (barStep - barSize) * barsAmount / 2; // if bar bigger than maxWidth, diff for x coordinate\r\n        var attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        if (axisOrient === 'top' || axisOrient === 'bottom') {\r\n            attrs.x = function (d) { return scales.scaleKey(d[keyField]) + margin.left + barSize * chartIndex + barDistance * chartIndex + barDiff; };\r\n            attrs.width = function (d) { return barSize; };\r\n        }\r\n        if (axisOrient === 'left' || axisOrient === 'right') {\r\n            attrs.y = function (d) { return scales.scaleKey(d[keyField]) + margin.top + barSize * chartIndex + barDistance * chartIndex + barDiff; };\r\n            attrs.height = function (d) { return barSize; };\r\n        }\r\n        if (axisOrient === 'top') {\r\n            attrs.y = function (d) { return margin.top; };\r\n            attrs.height = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scales.scaleValue(d[valueField])); };\r\n        }\r\n        else if (axisOrient === 'bottom') {\r\n            attrs.y = function (d) { return scales.scaleValue(d[valueField]) + margin.top; };\r\n            attrs.height = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.height - margin.top - margin.bottom - scales.scaleValue(d[valueField])); };\r\n        }\r\n        else if (axisOrient === 'left') {\r\n            attrs.x = function (d) { return margin.left + 1; };\r\n            attrs.width = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scales.scaleValue(d[valueField])); };\r\n        }\r\n        else if (axisOrient === 'right') {\r\n            attrs.x = function (d) { return scales.scaleValue(d[valueField]) + margin.left; };\r\n            attrs.width = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.width - margin.left - margin.right - scales.scaleValue(d[valueField])); };\r\n        }\r\n        return attrs;\r\n    };\r\n    Bar.getStackedBarAttrByKeyOrient = function (axisOrient, scales, margin, keyField, blockSize, barSettings) {\r\n        var barStep = (scale_1.Scale.getScaleWidth(scales.scaleKey));\r\n        var barSize = barStep > barSettings.maxBarWidth ? barSettings.maxBarWidth : barStep;\r\n        var barDiff = (barStep - barSize) / 2;\r\n        var attrs = {\r\n            x: null,\r\n            y: null,\r\n            width: null,\r\n            height: null\r\n        };\r\n        if (axisOrient === 'top' || axisOrient === 'bottom') {\r\n            attrs.x = function (d) { return scales.scaleKey(d.data[keyField]) + margin.left + barDiff; };\r\n            attrs.width = function (d) { return barSize; };\r\n        }\r\n        if (axisOrient === 'left' || axisOrient === 'right') {\r\n            attrs.y = function (d) { return scales.scaleKey(d.data[keyField]) + margin.top + barDiff; };\r\n            attrs.height = function (d) { return barSize; };\r\n        }\r\n        if (axisOrient === 'top') {\r\n            attrs.y = function (d) { return margin.top + scales.scaleValue(d[0]); };\r\n            attrs.height = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scales.scaleValue(d[1] - d[0])); };\r\n        }\r\n        if (axisOrient === 'bottom') {\r\n            attrs.y = function (d) { return scales.scaleValue(d[1]) + margin.top; };\r\n            attrs.height = function (d) { return blockSize.height - margin.top - margin.bottom - scales.scaleValue(d[1] - d[0]); };\r\n        }\r\n        if (axisOrient === 'left') {\r\n            attrs.x = function (d) { return margin.left + scales.scaleValue(d[0]) + 1; };\r\n            attrs.width = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scales.scaleValue(d[1] - d[0])); };\r\n        }\r\n        if (axisOrient === 'right') {\r\n            attrs.x = function (d) { return scales.scaleValue(d[1]) + margin.left; };\r\n            attrs.width = function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.width - margin.left - margin.right - scales.scaleValue(d[1] - d[0])); };\r\n        }\r\n        return attrs;\r\n    };\r\n    Bar.fillBarAttrsByKeyOrient = function (bars, barAttrs) {\r\n        bars.attr('x', function (d) { return barAttrs.x(d); })\r\n            .attr('y', function (d) { return barAttrs.y(d); })\r\n            .attr('height', function (d) { return barAttrs.height(d); })\r\n            .attr('width', function (d) { return barAttrs.width(d); });\r\n    };\r\n    Bar.fillBarAttrsByKeyOrientWithTransition = function (bars, axisOrient, scaleValue, margin, valueField, blockSize, transitionDuration) {\r\n        var barsTran = bars.transition().duration(transitionDuration);\r\n        if (axisOrient === 'top')\r\n            barsTran\r\n                .attr('y', function (d) { return margin.top; })\r\n                .attr('height', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scaleValue(d[valueField])); });\r\n        else if (axisOrient === 'bottom')\r\n            barsTran\r\n                .attr('y', function (d) { return scaleValue(d[valueField]) + margin.top; })\r\n                .attr('height', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.height - margin.top - margin.bottom - scaleValue(d[valueField])); });\r\n        else if (axisOrient === 'left')\r\n            barsTran\r\n                .attr('x', function (d) { return margin.left; })\r\n                .attr('width', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scaleValue(d[valueField])); });\r\n        else if (axisOrient === 'right')\r\n            barsTran\r\n                .attr('x', function (d) { return scaleValue(d[valueField]) + margin.left; })\r\n                .attr('width', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.width - margin.left - margin.right - scaleValue(d[valueField])); });\r\n    };\r\n    Bar.fillStackedBarAttrsByKeyOrientWithTransition = function (bars, axisOrient, scaleValue, margin, blockSize, transitionDuration) {\r\n        var barsTran = bars.transition().duration(transitionDuration);\r\n        if (axisOrient === 'bottom') {\r\n            barsTran\r\n                .attr('y', function (d) { return scaleValue(d[1]) + margin.top; })\r\n                .attr('height', function (d) { return blockSize.height - margin.top - margin.bottom - scaleValue(d[1] - d[0]); });\r\n        }\r\n        if (axisOrient === 'left') {\r\n            barsTran\r\n                .attr('x', function (d) { return margin.left + scaleValue(d[0]) + 1; })\r\n                .attr('width', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scaleValue(d[1] - d[0])); });\r\n        }\r\n        if (axisOrient === 'right') {\r\n            barsTran\r\n                .attr('x', function (d) { return scaleValue(d[1]) + margin.left; })\r\n                .attr('width', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(blockSize.width - margin.left - margin.right - scaleValue(d[1] - d[0])); });\r\n        }\r\n        if (axisOrient === 'top') {\r\n            barsTran\r\n                .attr('y', function (d) { return margin.top + scaleValue(d[0]); })\r\n                .attr('height', function (d) { return valueFormatter_1.ValueFormatter.getValueOrZero(scaleValue(d[1] - d[0])); });\r\n        }\r\n    };\r\n    Bar.setSegmentColor = function (segments, colorPalette) {\r\n        segments.style('fill', function (d, i) { return colorPalette[i % colorPalette.length].toString(); });\r\n    };\r\n    Bar.barItemClass = 'bar-item';\r\n    return Bar;\r\n}());\r\nexports.Bar = Bar;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/bar/bar.ts?");

/***/ }),

/***/ "./src/engine/twoDimensionalNotation/line/line.ts":
/*!********************************************************!*\
  !*** ./src/engine/twoDimensionalNotation/line/line.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Line = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar helper_1 = __webpack_require__(/*! ../../helper */ \"./src/engine/helper.ts\");\r\nvar scale_1 = __webpack_require__(/*! ../../features/scale/scale */ \"./src/engine/features/scale/scale.ts\");\r\nvar dot_1 = __webpack_require__(/*! ../../features/lineDots/dot */ \"./src/engine/features/lineDots/dot.ts\");\r\nvar Line = /** @class */ (function () {\r\n    function Line() {\r\n    }\r\n    Line.render = function (block, scales, data, margin, keyAxisOrient, chart, blockSize, isSegmented) {\r\n        if (isSegmented)\r\n            this.renderSegmented(block, scales, data, margin, keyAxisOrient, chart, blockSize);\r\n        else\r\n            this.renderGrouped(block, scales, data, margin, keyAxisOrient, chart, blockSize);\r\n    };\r\n    Line.updateLineChartByValueAxis = function (block, scales, data, margin, keyAxisOrient, chart) {\r\n        var _this = this;\r\n        chart.data.valueFields.forEach(function (valueField, index) {\r\n            var line = _this.getLineGenerator(keyAxisOrient, scales, chart.data.keyField.name, valueField.name, margin);\r\n            block.getChartBlock()\r\n                .select(\".\" + _this.lineChartClass + helper_1.Helper.getCssClassesLine(chart.cssClasses) + \".chart-element-\" + index)\r\n                .transition()\r\n                .duration(1000)\r\n                .attr('d', line(data));\r\n            dot_1.Dot.updateDotsCoordinateByValueAxis(block, data, keyAxisOrient, scales, margin, chart.data.keyField.name, valueField.name, chart.cssClasses, index, false);\r\n        });\r\n    };\r\n    Line.renderGrouped = function (block, scales, data, margin, keyAxisOrient, chart, blockSize) {\r\n        var _this = this;\r\n        chart.data.valueFields.forEach(function (valueField, index) {\r\n            var lineGenerator = _this.getLineGenerator(keyAxisOrient, scales, chart.data.keyField.name, valueField.name, margin);\r\n            var path = block.getChartBlock()\r\n                .append('path')\r\n                .attr('d', lineGenerator(data))\r\n                .attr('class', _this.lineChartClass)\r\n                .style('clip-path', \"url(\" + block.getClipPathId() + \")\")\r\n                .style('pointer-events', 'none');\r\n            helper_1.Helper.setCssClasses(path, helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, index));\r\n            helper_1.Helper.setChartStyle(path, chart.style, index, 'stroke');\r\n            dot_1.Dot.render(block, data, keyAxisOrient, scales, margin, chart.data.keyField.name, valueField.name, chart.cssClasses, index, chart.style.elementColors, blockSize, false);\r\n        });\r\n    };\r\n    Line.renderSegmented = function (block, scales, data, margin, keyAxisOrient, chart, blockSize) {\r\n        var keys = chart.data.valueFields.map(function (field) { return field.name; });\r\n        var stackedData = d3.stack().keys(keys)(data);\r\n        var lineGenerator = this.getSegmentedLineGenerator(keyAxisOrient, scales, chart.data.keyField.name, margin);\r\n        var areas = block.getChartBlock()\r\n            .selectAll('.area')\r\n            .data(stackedData)\r\n            .enter()\r\n            .append('path')\r\n            .attr('d', function (d) { return lineGenerator(d); })\r\n            .attr('class', this.lineChartClass)\r\n            .style('clip-path', \"url(\" + block.getClipPathId() + \")\")\r\n            .style('pointer-events', 'none');\r\n        areas.each(function (d, i) {\r\n            helper_1.Helper.setCssClasses(d3.select(this), helper_1.Helper.getCssClassesWithElementIndex(chart.cssClasses, i));\r\n        });\r\n        this.setSegmentColor(areas, chart.style.elementColors);\r\n        stackedData.forEach(function (sd, index) {\r\n            dot_1.Dot.render(block, sd, keyAxisOrient, scales, margin, chart.data.keyField.name, '1', chart.cssClasses, index, chart.style.elementColors, blockSize, true);\r\n        });\r\n    };\r\n    Line.getLineGenerator = function (keyAxisOrient, scales, keyFieldName, valueFieldName, margin) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return d3.line()\r\n                .x(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d[keyFieldName]) + margin.left; })\r\n                .y(function (d) { return scales.scaleValue(d[valueFieldName]) + margin.top; });\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return d3.line()\r\n                .x(function (d) { return scales.scaleValue(d[valueFieldName]) + margin.left; })\r\n                .y(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d[keyFieldName]) + margin.top; });\r\n        }\r\n    };\r\n    Line.getSegmentedLineGenerator = function (keyAxisOrient, scales, keyFieldName, margin) {\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            return d3.line()\r\n                .x(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d.data[keyFieldName]) + margin.left; })\r\n                .y(function (d) { return scales.scaleValue(d[1]) + margin.top; });\r\n        }\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            return d3.line()\r\n                .x(function (d) { return scales.scaleValue(d[1]) + margin.left; })\r\n                .y(function (d) { return scale_1.Scale.getScaleKeyPoint(scales.scaleKey, d.data[keyFieldName]) + margin.top; });\r\n        }\r\n    };\r\n    Line.setSegmentColor = function (segments, colorPalette) {\r\n        segments.style('stroke', function (d, i) { return colorPalette[i % colorPalette.length].toString(); });\r\n    };\r\n    Line.lineChartClass = 'line';\r\n    return Line;\r\n}());\r\nexports.Line = Line;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/twoDimensionalNotation/line/line.ts?");

/***/ }),

/***/ "./src/engine/valueFormatter.ts":
/*!**************************************!*\
  !*** ./src/engine/valueFormatter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ValueFormatter = void 0;\r\nvar ValueFormatter = /** @class */ (function () {\r\n    function ValueFormatter() {\r\n    }\r\n    ValueFormatter.formatValue = function (valueType, value) {\r\n        return this.format[valueType]({}, value);\r\n    };\r\n    ValueFormatter.setFormatFunction = function (formatFunction) {\r\n        this.format = formatFunction;\r\n    };\r\n    ValueFormatter.getValueOrZero = function (value) {\r\n        return value > 0 ? value : 0;\r\n    };\r\n    return ValueFormatter;\r\n}());\r\nexports.ValueFormatter = ValueFormatter;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/engine/valueFormatter.ts?");

/***/ }),

/***/ "./src/model/axisModel.ts":
/*!********************************!*\
  !*** ./src/model/axisModel.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.AxisModel = void 0;\r\nvar modelOptions_1 = __webpack_require__(/*! ./modelOptions */ \"./src/model/modelOptions.ts\");\r\nvar AxisModel = /** @class */ (function () {\r\n    function AxisModel() {\r\n    }\r\n    AxisModel.getLabelSize = function (labelMaxWidth, labelTexts) {\r\n        var labelSize = {\r\n            width: 0,\r\n            height: 0\r\n        };\r\n        var textBlock = document.createElement('span');\r\n        textBlock.style.position = 'absolute';\r\n        textBlock.classList.add(modelOptions_1.CLASSES.dataLabel);\r\n        var maxLabel = '';\r\n        var maxWidth = 0;\r\n        labelTexts.forEach(function (text) {\r\n            if (text.length > maxLabel.length)\r\n                maxLabel = text;\r\n        });\r\n        textBlock.textContent = maxLabel;\r\n        document.body.append(textBlock);\r\n        maxWidth = textBlock.getBoundingClientRect().width;\r\n        labelSize.height = textBlock.getBoundingClientRect().height;\r\n        labelSize.width = maxWidth > labelMaxWidth ? labelMaxWidth : maxWidth;\r\n        textBlock.remove();\r\n        return labelSize;\r\n    };\r\n    AxisModel.getAxisLength = function (chartOrientation, margin, blockSize) {\r\n        if (chartOrientation === 'horizontal') {\r\n            return blockSize.height - margin.top - margin.bottom;\r\n        }\r\n        else {\r\n            return blockSize.width - margin.left - margin.right;\r\n        }\r\n    };\r\n    AxisModel.getAxisOrient = function (axisType, chartOrientation, axisPosition) {\r\n        if (chartOrientation === 'vertical') {\r\n            if (axisPosition === 'start')\r\n                return axisType === modelOptions_1.AxisType.Key ? 'top' : 'left';\r\n            return axisType === modelOptions_1.AxisType.Key ? 'bottom' : 'right';\r\n        }\r\n        if (axisPosition === 'start')\r\n            return axisType === modelOptions_1.AxisType.Key ? 'left' : 'top';\r\n        return axisType === modelOptions_1.AxisType.Key ? 'right' : 'bottom';\r\n    };\r\n    AxisModel.getAxisTranslateX = function (axisType, chartOrientation, axisPosition, margin, blockWidth) {\r\n        var orient = AxisModel.getAxisOrient(axisType, chartOrientation, axisPosition);\r\n        if (orient === 'top' || orient === 'left')\r\n            return margin.left;\r\n        else if (orient === 'bottom')\r\n            return margin.left;\r\n        return blockWidth - margin.right;\r\n    };\r\n    AxisModel.getAxisTranslateY = function (axisType, chartOrientation, axisPosition, margin, blockHeight) {\r\n        var orient = AxisModel.getAxisOrient(axisType, chartOrientation, axisPosition);\r\n        if (orient === 'top' || orient === 'left')\r\n            return margin.top;\r\n        else if (orient === 'bottom')\r\n            return blockHeight - margin.bottom;\r\n        return margin.top;\r\n    };\r\n    AxisModel.getKeyAxisLabelPosition = function (margin, blockSize, scopedDataLength) {\r\n        var minBandSize = 50;\r\n        if ((blockSize.width - margin.left - margin.right) / scopedDataLength < minBandSize)\r\n            return 'rotated';\r\n        return 'straight';\r\n    };\r\n    return AxisModel;\r\n}());\r\nexports.AxisModel = AxisModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/axisModel.ts?");

/***/ }),

/***/ "./src/model/chartStyleModel.ts":
/*!**************************************!*\
  !*** ./src/model/chartStyleModel.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChartStyleModel = void 0;\r\nvar d3 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar d3_1 = __webpack_require__(/*! d3 */ \"./node_modules/d3/index.js\");\r\nvar ChartStyleModel = /** @class */ (function () {\r\n    function ChartStyleModel() {\r\n    }\r\n    ChartStyleModel.getCssClasses = function (chartIndex) {\r\n        var cssClasses = [\"chart-\" + chartIndex];\r\n        return cssClasses;\r\n    };\r\n    ChartStyleModel.get2DChartStyle = function (palette, chartsAmount, chartType, chartsValueFieldsAmount, chartIndex, isSegmented) {\r\n        return {\r\n            elementColors: this.get2DElementColorPalette(palette, chartsValueFieldsAmount, chartIndex, isSegmented),\r\n            opacity: this.getChartOpacity(chartsAmount, chartType)\r\n        };\r\n    };\r\n    ChartStyleModel.getChartStyle = function (palette, elementsAmount) {\r\n        return {\r\n            elementColors: this.getElementColorPalette(palette, elementsAmount),\r\n            opacity: 1\r\n        };\r\n    };\r\n    ChartStyleModel.getChartOpacity = function (chartsLength, chartType) {\r\n        if (chartsLength > 1 && chartType === 'area')\r\n            return 0.5; // combined area with other charts has 0.5 opacity\r\n        return 1;\r\n    };\r\n    ChartStyleModel.get2DElementColorPalette = function (palette, chartsValueFieldAmount, chartIndex, isSegmented) {\r\n        var startIndex = 0;\r\n        for (var i = 0; i < chartIndex; i++) {\r\n            startIndex += chartsValueFieldAmount[i];\r\n        }\r\n        return this.getColorsForFields(palette, startIndex, chartsValueFieldAmount[chartIndex], chartIndex, isSegmented);\r\n    };\r\n    ChartStyleModel.getElementColorPalette = function (palette, elementsAmount) {\r\n        var _this = this;\r\n        return palette.slice(0, elementsAmount).map(function (colors) { return d3_1.color(_this.getBaseColor(colors)); });\r\n    };\r\n    ChartStyleModel.getColorsForFields = function (palette, startIndex, valueFieldsAmount, chartIndex, isSegmented) {\r\n        if (!isSegmented) {\r\n            return this.getColorsWithAmountStep(palette, valueFieldsAmount, startIndex)\r\n                .map(function (elementColor) { return d3_1.color(elementColor); });\r\n        }\r\n        for (var i = 0; i < valueFieldsAmount; i++)\r\n            return this.getColorsSetByBase(palette[startIndex], valueFieldsAmount).map(function (colors) { return d3_1.color(colors); });\r\n    };\r\n    ChartStyleModel.getColorsWithAmountStep = function (palette, elementColors, startIndex) {\r\n        var step = Math.floor(19 / elementColors);\r\n        var colors = [];\r\n        var currentIndex = startIndex;\r\n        for (var i = 0; i < elementColors; i++) {\r\n            colors.push(this.getBaseColor(palette[currentIndex % 19]));\r\n            currentIndex += step;\r\n        }\r\n        return colors;\r\n    };\r\n    ChartStyleModel.getBaseColor = function (colorSet) {\r\n        var firstKey;\r\n        for (var key in colorSet) {\r\n            firstKey = firstKey || key;\r\n            if (parseInt(key.split('-')[key.split('-').length - 1]) === 500)\r\n                return colorSet[key];\r\n        }\r\n        return colorSet[firstKey];\r\n    };\r\n    ChartStyleModel.getColorsSetByBase = function (colorSet, colorsAmount) {\r\n        var colors = [];\r\n        for (var key in colorSet) {\r\n            var colorCode = parseInt(key.split('-')[key.split('-').length - 1]);\r\n            if (colorCode === 200 || colorCode === 300 || colorCode === 400 || colorCode === 500)\r\n                colors.push(colorSet[key]);\r\n        }\r\n        colors.reverse();\r\n        var chartColorSet = [];\r\n        for (var i = 0; i < colorsAmount; i++) {\r\n            chartColorSet.push(colors[i % colors.length]);\r\n        }\r\n        return chartColorSet;\r\n    };\r\n    ChartStyleModel.generatePalette = function (baseColors, colorAmount) {\r\n        var hslColor = d3.hsl(baseColors[0].toString());\r\n        var step = 360 / colorAmount;\r\n        if (step < 31)\r\n            step = 31;\r\n        var colors = [];\r\n        for (var i = 0; i < colorAmount; i++) {\r\n            colors.push(d3_1.color(hslColor));\r\n            hslColor.h += step;\r\n        }\r\n        return colors;\r\n    };\r\n    return ChartStyleModel;\r\n}());\r\nexports.ChartStyleModel = ChartStyleModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/chartStyleModel.ts?");

/***/ }),

/***/ "./src/model/dataManagerModel.ts":
/*!***************************************!*\
  !*** ./src/model/dataManagerModel.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DataManagerModel = void 0;\r\nvar axisModel_1 = __webpack_require__(/*! ./axisModel */ \"./src/model/axisModel.ts\");\r\nvar legendCanvasModel_1 = __webpack_require__(/*! ./legendModel/legendCanvasModel */ \"./src/model/legendModel/legendCanvasModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar modelHelper_1 = __webpack_require__(/*! ./modelHelper */ \"./src/model/modelHelper.ts\");\r\nvar DataManagerModel = /** @class */ (function () {\r\n    function DataManagerModel() {\r\n    }\r\n    DataManagerModel.getPreparedData = function (data, allowableKeys, config) {\r\n        var scopedData = this.getScopedData(data, allowableKeys, config);\r\n        this.setDataType(scopedData, config);\r\n        return scopedData;\r\n    };\r\n    DataManagerModel.getDataScope = function (config, margin, data, designerConfig, legendBlock) {\r\n        if (config.options.type === '2d' || config.options.type === 'interval') {\r\n            return this.getDataScopeFor2D(config.options, config.canvas.size, margin, data, designerConfig);\r\n        }\r\n        else if (config.options.type === 'polar') {\r\n            return this.getDataScopeForPolar(config.options, config.canvas.size, margin, data, designerConfig, legendBlock);\r\n        }\r\n    };\r\n    DataManagerModel.getDataValuesByKeyField = function (data, chart) {\r\n        return data[chart.data.dataSource].map(function (dataRow) { return dataRow[chart.data.keyField.name]; });\r\n    };\r\n    DataManagerModel.getElementsInGroupAmount = function (configOptions, chartsLength) {\r\n        if (configOptions.type === '2d' && !configOptions.isSegmented) {\r\n            return this.getBarChartsInGroupAmount(configOptions);\r\n        }\r\n        return chartsLength;\r\n    };\r\n    DataManagerModel.getDataScopeFor2D = function (configOptions, blockSize, margin, data, designerConfig) {\r\n        var charts = configOptions.charts\r\n            .filter(function (chart) { return chart.type === 'bar' || chart.type === 'gantt'; });\r\n        if (charts.length !== 0) {\r\n            var axisLength = axisModel_1.AxisModel.getAxisLength(configOptions.orientation, margin, blockSize);\r\n            var uniqueKeys = modelHelper_1.ModelHelper.getUniqueValues(data[charts[0].data.dataSource].map(function (d) { return d[charts[0].data.keyField.name]; }));\r\n            var dataLength = uniqueKeys.length;\r\n            var limit = this.getDataLimitByBarSize(this.getElementsInGroupAmount(configOptions, charts.length), dataLength, axisLength, designerConfig.canvas.chartOptions.bar);\r\n            var allowableKeys = uniqueKeys.slice(0, limit);\r\n            return {\r\n                allowableKeys: allowableKeys,\r\n                hidedRecordsAmount: dataLength - allowableKeys.length\r\n            };\r\n        }\r\n        return {\r\n            allowableKeys: this.getDataValuesByKeyField(data, configOptions.charts[0]),\r\n            hidedRecordsAmount: 0\r\n        };\r\n    };\r\n    DataManagerModel.getDataScopeForPolar = function (configOptions, blockSize, margin, data, designerConfig, legendBlock) {\r\n        var dataset = data[configOptions.charts[0].data.dataSource];\r\n        var keyFieldName = configOptions.charts[0].data.keyField.name;\r\n        var keys = dataset.map(function (dataRow) { return dataRow[keyFieldName]; });\r\n        if (configOptions.legend.position === 'off') {\r\n            return {\r\n                allowableKeys: keys,\r\n                hidedRecordsAmount: 0\r\n            };\r\n        }\r\n        var position;\r\n        if (blockSize.width - margin.left - margin.right >= legendModel_1.MIN_DONUT_BLOCK_SIZE)\r\n            position = 'right';\r\n        else\r\n            position = 'bottom';\r\n        if (position === 'right') {\r\n            if (blockSize.width - margin.left - margin.right < legendModel_1.MIN_DONUT_BLOCK_SIZE)\r\n                position = 'bottom';\r\n        }\r\n        var maxItemsNumber;\r\n        if (position === 'right') {\r\n            maxItemsNumber = legendCanvasModel_1.LegendCanvasModel.findElementsAmountByLegendSize(keys, position, 200, blockSize.height - margin.top - margin.bottom);\r\n        }\r\n        else {\r\n            var marginBottom = margin.bottom - (legendBlock.bottom.size === 0 ? legendBlock.bottom.size : legendBlock.bottom.size - legendBlock.bottom.margin.bottom);\r\n            maxItemsNumber = legendCanvasModel_1.LegendCanvasModel.findElementsAmountByLegendSize(keys, position, blockSize.width - margin.left - margin.right, blockSize.height - margin.top - marginBottom - legendBlock.bottom.margin.bottom - legendModel_1.MIN_DONUT_BLOCK_SIZE);\r\n        }\r\n        return {\r\n            allowableKeys: keys.slice(0, maxItemsNumber),\r\n            hidedRecordsAmount: keys.length - maxItemsNumber\r\n        };\r\n    };\r\n    DataManagerModel.getBarChartsInGroupAmount = function (configOptions) {\r\n        var barAmount = 0;\r\n        configOptions.charts.forEach(function (chart) {\r\n            if (chart.type === 'bar')\r\n                barAmount += chart.data.valueFields.length;\r\n        });\r\n        return barAmount;\r\n    };\r\n    DataManagerModel.getScopedData = function (data, allowableKeys, config) {\r\n        var _this = this;\r\n        var newData = {};\r\n        config.options.charts.forEach(function (chart) {\r\n            newData[chart.data.dataSource] = _this.getScopedChartData(data[chart.data.dataSource], allowableKeys, chart.data.keyField.name);\r\n        });\r\n        return newData;\r\n    };\r\n    DataManagerModel.getScopedChartData = function (data, allowableKeys, keyFieldName) {\r\n        return data.filter(function (d) { return allowableKeys.includes(d[keyFieldName]); });\r\n    };\r\n    DataManagerModel.setDataType = function (data, config) {\r\n        var _this = this;\r\n        if (config.options.type === 'polar' || config.options.type === '2d') {\r\n            config.options.charts.forEach(function (chart) {\r\n                if (chart.data.keyField.format === 'date') {\r\n                    data[chart.data.dataSource] = _this.getTypedData(data[chart.data.dataSource], chart.data.keyField.name, chart.data.keyField.format);\r\n                }\r\n            });\r\n        }\r\n        else if (config.options.type === 'interval') {\r\n            config.options.charts.forEach(function (chart) {\r\n                if (chart.data.valueField1.format === 'date') {\r\n                    data[chart.data.dataSource] = _this.getTypedData(data[chart.data.dataSource], chart.data.valueField1.name, chart.data.valueField1.format);\r\n                }\r\n                if (chart.data.valueField2.format === 'date') {\r\n                    data[chart.data.dataSource] = _this.getTypedData(data[chart.data.dataSource], chart.data.valueField2.name, chart.data.valueField2.format);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    DataManagerModel.getTypedData = function (data, fieldName, type) {\r\n        if (type === 'date')\r\n            data.forEach(function (d) {\r\n                d[fieldName] = new Date(d[fieldName]);\r\n            });\r\n        return data;\r\n    };\r\n    DataManagerModel.getDataLimitByBarSize = function (elementsInGroupAmount, dataLength, axisLength, barOptions) {\r\n        var sumSize = dataLength * (elementsInGroupAmount * barOptions.minBarWidth + (elementsInGroupAmount - 1) * barOptions.barDistance + barOptions.groupMinDistance);\r\n        while (dataLength !== 0 && axisLength < sumSize) {\r\n            dataLength--;\r\n            // find whole space for bars in group + distance between bars + group distance\r\n            sumSize = dataLength * (elementsInGroupAmount * barOptions.minBarWidth + (elementsInGroupAmount - 1)\r\n                * barOptions.barDistance + barOptions.groupMinDistance);\r\n        }\r\n        return dataLength;\r\n    };\r\n    return DataManagerModel;\r\n}());\r\nexports.DataManagerModel = DataManagerModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/dataManagerModel.ts?");

/***/ }),

/***/ "./src/model/gridLineModel.ts":
/*!************************************!*\
  !*** ./src/model/gridLineModel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.GridLineModel = void 0;\r\nvar GridLineModel = /** @class */ (function () {\r\n    function GridLineModel() {\r\n    }\r\n    GridLineModel.getGridLineOptions = function (configOptions, designerOptions) {\r\n        var gridKey = false;\r\n        var gridValue = false;\r\n        if (designerOptions.flag.value)\r\n            gridValue = configOptions.flag.value;\r\n        if (designerOptions.flag.key)\r\n            gridKey = configOptions.flag.key;\r\n        return {\r\n            flag: {\r\n                value: gridValue,\r\n                key: gridKey\r\n            }\r\n        };\r\n    };\r\n    return GridLineModel;\r\n}());\r\nexports.GridLineModel = GridLineModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/gridLineModel.ts?");

/***/ }),

/***/ "./src/model/intervalModel.ts":
/*!************************************!*\
  !*** ./src/model/intervalModel.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.IntervalModel = void 0;\r\nvar axisModel_1 = __webpack_require__(/*! ./axisModel */ \"./src/model/axisModel.ts\");\r\nvar chartStyleModel_1 = __webpack_require__(/*! ./chartStyleModel */ \"./src/model/chartStyleModel.ts\");\r\nvar dataManagerModel_1 = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\r\nvar gridLineModel_1 = __webpack_require__(/*! ./gridLineModel */ \"./src/model/gridLineModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar modelOptions_1 = __webpack_require__(/*! ./modelOptions */ \"./src/model/modelOptions.ts\");\r\nvar scaleModel_1 = __webpack_require__(/*! ./scaleModel */ \"./src/model/scaleModel.ts\");\r\nvar IntervalModel = /** @class */ (function () {\r\n    function IntervalModel() {\r\n    }\r\n    IntervalModel.getOptions = function (config, designerConfig, margin, dataScope, data) {\r\n        var configOptions = config.options;\r\n        return {\r\n            legend: legendModel_1.LegendModel.getLegendModel(config.options.type, config.options.legend.position, config.canvas.size, margin),\r\n            orient: configOptions.orientation,\r\n            scale: {\r\n                scaleKey: {\r\n                    domain: scaleModel_1.ScaleModel.getScaleKeyDomain(dataScope.allowableKeys),\r\n                    range: {\r\n                        start: 0,\r\n                        end: scaleModel_1.ScaleModel.getScaleRangePeek(scaleModel_1.ScaleType.Key, configOptions.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: scaleModel_1.ScaleModel.getScaleKeyType(configOptions.charts),\r\n                    elementsAmount: configOptions.charts.length\r\n                },\r\n                scaleValue: {\r\n                    domain: scaleModel_1.ScaleModel.getScaleDateValueDomain(data, configOptions.charts, configOptions.axis.keyAxis.position, dataScope.allowableKeys),\r\n                    range: {\r\n                        start: 0,\r\n                        end: scaleModel_1.ScaleModel.getScaleRangePeek(scaleModel_1.ScaleType.Value, configOptions.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: scaleModel_1.ScaleModel.getScaleValueType(configOptions.charts)\r\n                }\r\n            },\r\n            axis: {\r\n                keyAxis: {\r\n                    type: 'key',\r\n                    orient: axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position),\r\n                    translate: {\r\n                        translateX: axisModel_1.AxisModel.getAxisTranslateX(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position, margin, config.canvas.size.width),\r\n                        translateY: axisModel_1.AxisModel.getAxisTranslateY(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'key-axis',\r\n                    ticks: configOptions.axis.keyAxis.ticks,\r\n                    labels: {\r\n                        maxSize: designerConfig.canvas.axisLabel.maxSize.main,\r\n                        positition: axisModel_1.AxisModel.getKeyAxisLabelPosition(margin, config.canvas.size, dataManagerModel_1.DataManagerModel.getDataValuesByKeyField(data, configOptions.charts[0]).length),\r\n                        visible: true\r\n                    }\r\n                },\r\n                valueAxis: {\r\n                    type: 'value',\r\n                    orient: axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position),\r\n                    translate: {\r\n                        translateX: axisModel_1.AxisModel.getAxisTranslateX(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position, margin, config.canvas.size.width),\r\n                        translateY: axisModel_1.AxisModel.getAxisTranslateY(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'value-axis',\r\n                    ticks: configOptions.axis.valueAxis.ticks,\r\n                    labels: {\r\n                        maxSize: designerConfig.canvas.axisLabel.maxSize.main,\r\n                        positition: 'straight',\r\n                        visible: true\r\n                    }\r\n                }\r\n            },\r\n            type: configOptions.type,\r\n            charts: this.getChartsModel(configOptions.charts, designerConfig.chart.style.palette),\r\n            additionalElements: this.getAdditionalElements(configOptions, designerConfig)\r\n        };\r\n    };\r\n    IntervalModel.getAdditionalElements = function (options, designerConfig) {\r\n        return {\r\n            gridLine: gridLineModel_1.GridLineModel.getGridLineOptions(options.additionalElements.gridLine, designerConfig.additionalElements.gridLine)\r\n        };\r\n    };\r\n    IntervalModel.getChartsModel = function (charts, chartPalette) {\r\n        var chartsModel = [];\r\n        charts.forEach(function (chart, index) {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                title: chart.title,\r\n                data: __assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: chartStyleModel_1.ChartStyleModel.getCssClasses(index),\r\n                style: chartStyleModel_1.ChartStyleModel.getChartStyle(chartPalette, charts.length)\r\n            });\r\n        });\r\n        return chartsModel;\r\n    };\r\n    return IntervalModel;\r\n}());\r\nexports.IntervalModel = IntervalModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/intervalModel.ts?");

/***/ }),

/***/ "./src/model/legendModel/legendCanvasModel.ts":
/*!****************************************************!*\
  !*** ./src/model/legendModel/legendCanvasModel.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LegendCanvasModel = void 0;\r\nvar modelOptions_1 = __webpack_require__(/*! ../modelOptions */ \"./src/model/modelOptions.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar LegendCanvasModel = /** @class */ (function () {\r\n    function LegendCanvasModel() {\r\n    }\r\n    LegendCanvasModel.getLegendHeight = function (texts, blockWidth, marginLeft, marginRight, itemsPosition, legendPosition) {\r\n        var legendWrapper = document.createElement('div');\r\n        legendWrapper.style.display = 'flex';\r\n        if (itemsPosition === 'column')\r\n            legendWrapper.style.flexDirection = 'column';\r\n        legendWrapper.style.position = 'absolute';\r\n        legendWrapper.style.width = blockWidth - marginLeft - marginRight + 'px';\r\n        texts.forEach(function (text) {\r\n            var itemWrapper = document.createElement('div');\r\n            var colorBlock = document.createElement('span');\r\n            var textBlock = document.createElement('span');\r\n            itemWrapper.classList.add(legendModel_1.LegendModel.getLegendItemClass(itemsPosition));\r\n            if (itemsPosition === 'column')\r\n                itemWrapper.classList.add(legendModel_1.LegendModel.getMarginClass(legendPosition));\r\n            colorBlock.classList.add(modelOptions_1.CLASSES.legendColor);\r\n            textBlock.classList.add(modelOptions_1.CLASSES.legendLabel);\r\n            textBlock.textContent = text;\r\n            itemWrapper.append(colorBlock, textBlock);\r\n            legendWrapper.append(itemWrapper);\r\n        });\r\n        document.body.append(legendWrapper);\r\n        var height = legendWrapper.offsetHeight;\r\n        legendWrapper.remove();\r\n        return height;\r\n    };\r\n    LegendCanvasModel.getLegendItemWidth = function (text) {\r\n        var itemWrapper = document.createElement('div');\r\n        var colorBlock = document.createElement('span');\r\n        var textBlock = document.createElement('span');\r\n        itemWrapper.style.display = 'inline-block';\r\n        itemWrapper.classList.add(modelOptions_1.CLASSES.legendItem);\r\n        colorBlock.classList.add(modelOptions_1.CLASSES.legendColor);\r\n        textBlock.classList.add(modelOptions_1.CLASSES.legendLabel);\r\n        textBlock.textContent = text;\r\n        itemWrapper.append(colorBlock, textBlock);\r\n        document.body.append(itemWrapper);\r\n        var sumWidth = itemWrapper.getBoundingClientRect().width\r\n            + parseFloat(window.getComputedStyle(itemWrapper, null).getPropertyValue('margin-left'))\r\n            + parseFloat(window.getComputedStyle(itemWrapper, null).getPropertyValue('margin-right'));\r\n        itemWrapper.remove();\r\n        return sumWidth;\r\n    };\r\n    LegendCanvasModel.findElementsAmountByLegendSize = function (texts, position, legendBlockWidth, legendBlockHeight) {\r\n        var legendWrapper = document.createElement('div');\r\n        legendWrapper.style.display = 'flex';\r\n        legendWrapper.style.flexDirection = 'column';\r\n        legendWrapper.style.position = 'absolute';\r\n        legendWrapper.style.width = legendBlockWidth + 'px';\r\n        document.body.append(legendWrapper);\r\n        var amount = 0;\r\n        for (var i = 0; i < texts.length; i++) {\r\n            var itemWrapper = document.createElement('div');\r\n            var colorBlock = document.createElement('span');\r\n            var textBlock = document.createElement('span');\r\n            itemWrapper.classList.add('legend-item-row');\r\n            if (position === 'bottom')\r\n                textBlock.classList.add('legend-label-nowrap', 'mt-10');\r\n            else\r\n                itemWrapper.classList.add('mt-15');\r\n            colorBlock.classList.add(modelOptions_1.CLASSES.legendColor);\r\n            textBlock.classList.add(modelOptions_1.CLASSES.legendLabel);\r\n            textBlock.textContent = texts[i];\r\n            itemWrapper.append(colorBlock, textBlock);\r\n            legendWrapper.append(itemWrapper);\r\n            if (legendWrapper.offsetHeight > legendBlockHeight) {\r\n                itemWrapper.remove();\r\n                if (legendBlockHeight - legendWrapper.offsetHeight >= 15)\r\n                    amount = i;\r\n                else\r\n                    amount = i - 1;\r\n                break;\r\n            }\r\n            amount++;\r\n        }\r\n        legendWrapper.remove();\r\n        return amount < 0 ? 0 : amount;\r\n    };\r\n    return LegendCanvasModel;\r\n}());\r\nexports.LegendCanvasModel = LegendCanvasModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/legendModel/legendCanvasModel.ts?");

/***/ }),

/***/ "./src/model/legendModel/legendModel.ts":
/*!**********************************************!*\
  !*** ./src/model/legendModel/legendModel.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LegendModel = exports.MIN_DONUT_BLOCK_SIZE = void 0;\r\nvar legendCanvasModel_1 = __webpack_require__(/*! ./legendCanvasModel */ \"./src/model/legendModel/legendCanvasModel.ts\");\r\n/** If donut block has width less than this const, legend change postion from \"right\" to \"bottom\" */\r\nexports.MIN_DONUT_BLOCK_SIZE = 260;\r\nvar LegendModel = /** @class */ (function () {\r\n    function LegendModel() {\r\n    }\r\n    LegendModel.getLegendSize = function (chartNotation, position, texts, legendMaxWidth, blockSize, legendBlockModel) {\r\n        if (position === 'left' || position === 'right')\r\n            return this.getLegendWidth(texts, legendMaxWidth);\r\n        if (chartNotation === '2d' || chartNotation === 'interval') {\r\n            return legendCanvasModel_1.LegendCanvasModel.getLegendHeight(texts, blockSize.width, legendBlockModel[position].margin.left, legendBlockModel[position].margin.right, 'row', position);\r\n        }\r\n        else if (chartNotation === 'polar') {\r\n            var size = legendCanvasModel_1.LegendCanvasModel.getLegendHeight(texts, blockSize.width, legendBlockModel[position].margin.left, legendBlockModel[position].margin.right, 'column', position);\r\n            return size;\r\n        }\r\n    };\r\n    LegendModel.getBaseLegendBlockModel = function () {\r\n        var mt = 20, mb = 20, ml = 20, mr = 20;\r\n        return {\r\n            left: {\r\n                size: 0,\r\n                margin: { top: mt, bottom: mb, left: ml, right: 0 }\r\n            },\r\n            right: {\r\n                size: 0,\r\n                margin: { top: mt, bottom: mb, left: 0, right: mr }\r\n            },\r\n            bottom: {\r\n                size: 0,\r\n                margin: { top: 0, bottom: 20, left: 20, right: 20 }\r\n            },\r\n            top: {\r\n                size: 0,\r\n                margin: { top: 20, bottom: 0, left: 20, right: 20 }\r\n            }\r\n        };\r\n    };\r\n    LegendModel.getLegendModel = function (chartNotation, position, blockSize, margin) {\r\n        var legendPosition = 'off';\r\n        if (position !== 'off') {\r\n            if (chartNotation === '2d' || chartNotation === 'interval')\r\n                legendPosition = 'top';\r\n            else if (chartNotation === 'polar') {\r\n                legendPosition = blockSize.width - margin.left - margin.right < exports.MIN_DONUT_BLOCK_SIZE ? 'bottom' : 'right';\r\n            }\r\n        }\r\n        return {\r\n            position: legendPosition\r\n        };\r\n    };\r\n    LegendModel.getLegendItemClass = function (itemsPosition) {\r\n        return itemsPosition === 'column' ? 'legend-item-row' : 'legend-item-inline';\r\n    };\r\n    LegendModel.getMarginClass = function (legendPosition) {\r\n        return legendPosition === 'right' ? 'mt-15' : 'mt-10';\r\n    };\r\n    LegendModel.getLegendWidth = function (texts, legendMaxWidth) {\r\n        var _this = this;\r\n        var longestText = '';\r\n        var biggestScore = 0;\r\n        texts.forEach(function (text) {\r\n            if (_this.getStringScore(text) > biggestScore) {\r\n                longestText = text;\r\n                biggestScore = _this.getStringScore(text);\r\n            }\r\n        });\r\n        var maxWidth = legendCanvasModel_1.LegendCanvasModel.getLegendItemWidth(longestText + '?'); // One letter reserve\r\n        return maxWidth > legendMaxWidth ? legendMaxWidth : maxWidth;\r\n    };\r\n    LegendModel.getStringScore = function (word) {\r\n        // lower case letter width ~ 0.74 from upper case width.\r\n        // Number width == lower case letter width\r\n        var score = 0;\r\n        var upperLetterScore = 1;\r\n        var lowerLetterScore = 0.74;\r\n        for (var i = 0; i < word.length; i++) {\r\n            if (word[i].toUpperCase() === word[i] && parseFloat(word[i]).toString() !== word[i])\r\n                score += upperLetterScore;\r\n            else\r\n                score += lowerLetterScore;\r\n        }\r\n        return score;\r\n    };\r\n    return LegendModel;\r\n}());\r\nexports.LegendModel = LegendModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/legendModel/legendModel.ts?");

/***/ }),

/***/ "./src/model/marginModel.ts":
/*!**********************************!*\
  !*** ./src/model/marginModel.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.MarginModel = exports.AXIS_VERTICAL_LABEL_PADDING = exports.AXIS_HORIZONTAL_LABEL_PADDING = void 0;\r\nvar axisModel_1 = __webpack_require__(/*! ./axisModel */ \"./src/model/axisModel.ts\");\r\nvar dataManagerModel_1 = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar modelOptions_1 = __webpack_require__(/*! ./modelOptions */ \"./src/model/modelOptions.ts\");\r\nvar twoDimensionalModel_1 = __webpack_require__(/*! ./twoDimensionalModel */ \"./src/model/twoDimensionalModel.ts\");\r\nexports.AXIS_HORIZONTAL_LABEL_PADDING = 15;\r\nexports.AXIS_VERTICAL_LABEL_PADDING = 10;\r\nvar MarginModel = /** @class */ (function () {\r\n    function MarginModel() {\r\n    }\r\n    MarginModel.getMargin = function (designerConfig, config, legendBlockModel, data) {\r\n        var margin = __assign({}, designerConfig.canvas.chartBlockMargin);\r\n        this.recalcMarginWithLegend(margin, config, designerConfig.canvas.legendBlock.maxWidth, legendBlockModel, data);\r\n        if (config.options.type === '2d' || config.options.type === 'interval') {\r\n            var labelSize = this.getMarginValuesByAxisLabels(config.options.charts, designerConfig.canvas.axisLabel.maxSize.main, config.options.axis, data, config.options);\r\n            this.recalcMarginWithAxisLabelHeight(labelSize, margin, config.options, config.options.axis);\r\n            var showingFlag = config.options.type === '2d'\r\n                ? !twoDimensionalModel_1.TwoDimensionalModel.getChartsEmbeddedLabelsFlag(config.options.charts, config.options, data, config.options.orientation, config.canvas.size, margin, designerConfig.canvas.chartOptions.bar, config.options.isSegmented)\r\n                : true; // If embedded labels displays, axis key labels doesn't show\r\n            this.recalcMarginWithAxisLabelWidth(labelSize, margin, config.options, config.options.axis, showingFlag);\r\n        }\r\n        return margin;\r\n    };\r\n    MarginModel.recalcPolarMarginWithScopedData = function (margin, blockSize, designerConfig, config, legendBlockModel, dataScope, options) {\r\n        var position = legendModel_1.LegendModel.getLegendModel(config.options.type, config.options.legend.position, config.canvas.size, margin).position;\r\n        if (position !== 'off') {\r\n            if (position === 'right' && blockSize.width - margin.left - margin.right < legendModel_1.MIN_DONUT_BLOCK_SIZE)\r\n                position = 'bottom';\r\n            this.clearMarginByLegendBlockPosition(margin, legendBlockModel);\r\n            var legendSize = legendModel_1.LegendModel.getLegendSize(config.options.type, position, dataScope.allowableKeys, designerConfig.canvas.legendBlock.maxWidth, config.canvas.size, legendBlockModel);\r\n            margin[position] += legendSize + legendBlockModel[position].margin[position];\r\n            legendBlockModel[position].size = legendSize;\r\n            options.legend.position = position;\r\n        }\r\n    };\r\n    MarginModel.recalcMargnWitVerticalAxisLabel = function (margin, data, config, designerConfig) {\r\n        if ((config.options.type === '2d' || config.options.type === 'interval') && config.options.orientation === 'vertical' && config.options.axis.keyAxis.position === 'end') {\r\n            var labelTexts = dataManagerModel_1.DataManagerModel.getDataValuesByKeyField(data, config.options.charts[0]);\r\n            var axisLabelSize = axisModel_1.AxisModel.getLabelSize(designerConfig.canvas.axisLabel.maxSize.main, labelTexts);\r\n            var axisConfig = axisModel_1.AxisModel.getKeyAxisLabelPosition(margin, config.canvas.size, labelTexts.length);\r\n            if (axisConfig === 'rotated')\r\n                margin.bottom += (axisLabelSize.width - axisLabelSize.height);\r\n        }\r\n    };\r\n    MarginModel.getMarginValuesByAxisLabels = function (charts, labelsMaxWidth, axis, data, options) {\r\n        var keyAxisOrient = axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Key, options.orientation, axis.keyAxis.position);\r\n        var labelsTexts;\r\n        if (keyAxisOrient === 'left' || keyAxisOrient === 'right') {\r\n            labelsTexts = dataManagerModel_1.DataManagerModel.getDataValuesByKeyField(data, charts[0]);\r\n        }\r\n        else {\r\n            labelsTexts = ['0000'];\r\n        }\r\n        return axisModel_1.AxisModel.getLabelSize(labelsMaxWidth, labelsTexts);\r\n    };\r\n    MarginModel.recalcMarginWithAxisLabelHeight = function (labelSize, margin, options, axis) {\r\n        var keyAxisOrient = axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Key, options.orientation, axis.keyAxis.position);\r\n        var valueAxisOrient = axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Value, options.orientation, axis.valueAxis.position);\r\n        if (keyAxisOrient === 'bottom' || keyAxisOrient === 'top') {\r\n            margin[keyAxisOrient] += labelSize.height + exports.AXIS_HORIZONTAL_LABEL_PADDING;\r\n        }\r\n        else {\r\n            margin[valueAxisOrient] += labelSize.height + exports.AXIS_HORIZONTAL_LABEL_PADDING;\r\n        }\r\n    };\r\n    MarginModel.recalcMarginWithAxisLabelWidth = function (labelSize, margin, options, axis, isShow) {\r\n        var keyAxisOrient = axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Key, options.orientation, axis.keyAxis.position);\r\n        var valueAxisOrient = axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Value, options.orientation, axis.valueAxis.position);\r\n        if ((keyAxisOrient === 'left' || keyAxisOrient === 'right') && isShow) {\r\n            margin[keyAxisOrient] += labelSize.width + exports.AXIS_VERTICAL_LABEL_PADDING;\r\n        }\r\n        else if (valueAxisOrient === 'left' || valueAxisOrient === 'right') {\r\n            margin[valueAxisOrient] += labelSize.width + exports.AXIS_VERTICAL_LABEL_PADDING;\r\n        }\r\n    };\r\n    MarginModel.recalcMarginWithLegend = function (margin, config, legendMaxWidth, legendBlockModel, data) {\r\n        var legendPosition = legendModel_1.LegendModel.getLegendModel(config.options.type, config.options.legend.position, config.canvas.size, margin).position;\r\n        if (legendPosition !== 'off') {\r\n            var legendItemsContent = this.getLegendItemsContent(config.options.charts, config.options, data);\r\n            var legendSize = legendModel_1.LegendModel.getLegendSize(config.options.type, legendPosition, legendItemsContent, legendMaxWidth, config.canvas.size, legendBlockModel);\r\n            margin[legendPosition] += legendSize;\r\n            if (legendSize !== 0)\r\n                this.appendToGlobalMarginValuesLegendMargin(margin, legendPosition, legendBlockModel);\r\n            legendBlockModel[legendPosition].size = legendSize;\r\n        }\r\n    };\r\n    MarginModel.getLegendItemsContent = function (charts, options, data) {\r\n        if (options.type === '2d') {\r\n            var texts_1 = [];\r\n            options.charts.forEach(function (chart) {\r\n                texts_1 = texts_1.concat(chart.data.valueFields.map(function (field) { return field.title; }));\r\n            });\r\n            return texts_1;\r\n        }\r\n        else if (options.type === 'polar') {\r\n            return charts.map(function (chart) { return dataManagerModel_1.DataManagerModel.getDataValuesByKeyField(data, chart); })[0];\r\n        }\r\n        else if (options.type === 'interval') {\r\n            return charts.map(function (chart) { return chart.title; });\r\n        }\r\n    };\r\n    MarginModel.appendToGlobalMarginValuesLegendMargin = function (margin, position, legendBlockModel) {\r\n        if (position === 'left' || position === 'right')\r\n            margin[position] += legendBlockModel[position].margin.left + legendBlockModel[position].margin.right;\r\n        else\r\n            margin[position] += legendBlockModel[position].margin.top + legendBlockModel[position].margin.bottom;\r\n    };\r\n    MarginModel.clearMarginByLegendBlockPosition = function (margin, legendBlockModel) {\r\n        ['left', 'right', 'top', 'bottom'].forEach(function (position) {\r\n            margin[position] -= legendBlockModel[position].size === 0\r\n                ? 0\r\n                : legendBlockModel[position].size + legendBlockModel[position].margin[position];\r\n        });\r\n    };\r\n    return MarginModel;\r\n}());\r\nexports.MarginModel = MarginModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/marginModel.ts?");

/***/ }),

/***/ "./src/model/modelHelper.ts":
/*!**********************************!*\
  !*** ./src/model/modelHelper.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ModelHelper = void 0;\r\nvar ModelHelper = /** @class */ (function () {\r\n    function ModelHelper() {\r\n    }\r\n    ModelHelper.getValuesSum = function (values) {\r\n        var sum = 0;\r\n        for (var i = 0; i < values.length; i++) {\r\n            sum += values[i];\r\n        }\r\n        return sum;\r\n    };\r\n    ModelHelper.getMaxNumberValue = function (values) {\r\n        var max = values[0];\r\n        for (var i = 0; i < values.length; i++) {\r\n            if (max < values[i])\r\n                max = values[i];\r\n        }\r\n        return max;\r\n    };\r\n    ModelHelper.getMinAndMaxOfIntervalData = function (data, charts) {\r\n        var min = data[charts[0].data.dataSource][0][charts[0].data.valueField1.name];\r\n        var max = data[charts[0].data.dataSource][0][charts[0].data.valueField1.name];\r\n        charts.forEach(function (chart) {\r\n            var chartData = data[chart.data.dataSource];\r\n            var valueField1 = chart.data.valueField1.name;\r\n            var valueField2 = chart.data.valueField2.name;\r\n            chartData.forEach(function (dataRow) {\r\n                if (dataRow[valueField1] > max)\r\n                    max = dataRow[valueField1];\r\n                if (dataRow[valueField1] < min)\r\n                    min = dataRow[valueField1];\r\n                if (dataRow[valueField2] > max)\r\n                    max = dataRow[valueField2];\r\n                if (dataRow[valueField2] < min)\r\n                    min = dataRow[valueField2];\r\n            });\r\n        });\r\n        return [min, max];\r\n    };\r\n    ModelHelper.getDonutRadius = function (margin, blockSize) {\r\n        return Math.min(blockSize.height - margin.top - margin.bottom, blockSize.width - margin.left - margin.right) / 2;\r\n    };\r\n    ModelHelper.getAngleByValue = function (value, valuesSum) {\r\n        return value / valuesSum * 360;\r\n    };\r\n    ModelHelper.getMinAngleByLength = function (minLength, radius) {\r\n        return minLength * 360 / (2 * Math.PI * radius);\r\n    };\r\n    ModelHelper.getUniqueValues = function (values) {\r\n        var uniqueValues = values.filter(function (keyValue, index, self) { return self.indexOf(keyValue) === index; });\r\n        return uniqueValues;\r\n    };\r\n    ModelHelper.getUniqueValuesLength = function (values) {\r\n        return this.getUniqueValues(values).length;\r\n    };\r\n    return ModelHelper;\r\n}());\r\nexports.ModelHelper = ModelHelper;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/modelHelper.ts?");

/***/ }),

/***/ "./src/model/modelOptions.ts":
/*!***********************************!*\
  !*** ./src/model/modelOptions.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getUpdatedModel = exports.getPreparedData = exports.assembleModel = exports.CLASSES = exports.AxisType = void 0;\r\nvar marginModel_1 = __webpack_require__(/*! ./marginModel */ \"./src/model/marginModel.ts\");\r\nvar twoDimensionalModel_1 = __webpack_require__(/*! ./twoDimensionalModel */ \"./src/model/twoDimensionalModel.ts\");\r\nvar polarModel_1 = __webpack_require__(/*! ./polarModel */ \"./src/model/polarModel.ts\");\r\n__webpack_require__(/*! ../style/main.css */ \"./src/style/main.css\");\r\nvar dataManagerModel_1 = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\r\nvar intervalModel_1 = __webpack_require__(/*! ./intervalModel */ \"./src/model/intervalModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar AxisType;\r\n(function (AxisType) {\r\n    AxisType[AxisType[\"Key\"] = 0] = \"Key\";\r\n    AxisType[AxisType[\"Value\"] = 1] = \"Value\";\r\n})(AxisType = exports.AxisType || (exports.AxisType = {}));\r\nexports.CLASSES = {\r\n    dataLabel: 'data-label',\r\n    legendLabel: 'legend-label',\r\n    legendColor: 'legend-circle',\r\n    legendItem: 'legend-item',\r\n};\r\nfunction getBlockCanvas(config) {\r\n    return {\r\n        size: {\r\n            width: config.canvas.size.width,\r\n            height: config.canvas.size.height\r\n        },\r\n        cssClass: config.canvas.class\r\n    };\r\n}\r\nfunction getChartBlock(margin) {\r\n    return {\r\n        margin: margin\r\n    };\r\n}\r\nfunction getOptions(config, designerConfig, margin, dataScope, data) {\r\n    if (config.options.type === '2d') {\r\n        return twoDimensionalModel_1.TwoDimensionalModel.getOptions(config, designerConfig, margin, dataScope, data);\r\n    }\r\n    else if (config.options.type === 'polar') {\r\n        return polarModel_1.PolarModel.getOptions(config, designerConfig.chart.style.palette, data, margin);\r\n    }\r\n    else if (config.options.type === 'interval') {\r\n        return intervalModel_1.IntervalModel.getOptions(config, designerConfig, margin, dataScope, data);\r\n    }\r\n}\r\nfunction getDataSettings(dataScope) {\r\n    return {\r\n        scope: dataScope\r\n    };\r\n}\r\nfunction getChartSettings(barSettings, donutSettings) {\r\n    return {\r\n        bar: __assign({}, barSettings),\r\n        donut: {\r\n            padAngle: donutSettings.padAngle,\r\n            maxThickness: donutSettings.maxThickness,\r\n            minThickness: donutSettings.minThickness,\r\n        }\r\n    };\r\n}\r\nfunction getDataFormat(designerConfig) {\r\n    return {\r\n        formatters: designerConfig.dataFormat.formatters\r\n    };\r\n}\r\nfunction assembleModel(config, data, designerConfig) {\r\n    var legendBlock = legendModel_1.LegendModel.getBaseLegendBlockModel();\r\n    var margin = marginModel_1.MarginModel.getMargin(designerConfig, config, legendBlock, data);\r\n    var dataScope = dataManagerModel_1.DataManagerModel.getDataScope(config, margin, data, designerConfig, legendBlock);\r\n    var preparedData = dataManagerModel_1.DataManagerModel.getPreparedData(data, dataScope.allowableKeys, config);\r\n    if (config.options.type === '2d' || config.options.type === 'interval')\r\n        marginModel_1.MarginModel.recalcMargnWitVerticalAxisLabel(margin, data, config, designerConfig);\r\n    var blockCanvas = getBlockCanvas(config);\r\n    var chartBlock = getChartBlock(margin);\r\n    var options = getOptions(config, designerConfig, margin, dataScope, preparedData);\r\n    var dataSettings = getDataSettings(dataScope);\r\n    var chartSettings = getChartSettings(designerConfig.canvas.chartOptions.bar, designerConfig.canvas.chartOptions.donut);\r\n    var dataFormat = getDataFormat(designerConfig);\r\n    if (options.type === 'polar')\r\n        marginModel_1.MarginModel.recalcPolarMarginWithScopedData(margin, config.canvas.size, designerConfig, config, legendBlock, dataScope, options);\r\n    return {\r\n        blockCanvas: blockCanvas,\r\n        chartBlock: chartBlock,\r\n        legendBlock: legendBlock,\r\n        options: options,\r\n        dataSettings: dataSettings,\r\n        chartSettings: chartSettings,\r\n        dataFormat: dataFormat\r\n    };\r\n}\r\nexports.assembleModel = assembleModel;\r\nfunction getPreparedData(model, data, config) {\r\n    var preparedData = dataManagerModel_1.DataManagerModel.getPreparedData(data, model.dataSettings.scope.allowableKeys, config);\r\n    return preparedData;\r\n}\r\nexports.getPreparedData = getPreparedData;\r\nfunction getUpdatedModel(config, data, designerConfig) {\r\n    return assembleModel(config, data, designerConfig);\r\n}\r\nexports.getUpdatedModel = getUpdatedModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/modelOptions.ts?");

/***/ }),

/***/ "./src/model/polarModel.ts":
/*!*********************************!*\
  !*** ./src/model/polarModel.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PolarModel = void 0;\r\nvar chartStyleModel_1 = __webpack_require__(/*! ./chartStyleModel */ \"./src/model/chartStyleModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar PolarModel = /** @class */ (function () {\r\n    function PolarModel() {\r\n    }\r\n    PolarModel.getOptions = function (config, chartPalette, data, margin) {\r\n        var configOptions = config.options;\r\n        return {\r\n            type: configOptions.type,\r\n            charts: this.getChartsModel(configOptions.charts, chartPalette, data),\r\n            legend: legendModel_1.LegendModel.getLegendModel(config.options.type, config.options.legend.position, config.canvas.size, margin)\r\n        };\r\n    };\r\n    PolarModel.getChartsModel = function (charts, chartPalette, data) {\r\n        var chartsModel = [];\r\n        charts.forEach(function (chart, index) {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                title: chart.title,\r\n                data: __assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: chartStyleModel_1.ChartStyleModel.getCssClasses(index),\r\n                style: chartStyleModel_1.ChartStyleModel.getChartStyle(chartPalette, data[chart.data.dataSource].length)\r\n            });\r\n        });\r\n        return chartsModel;\r\n    };\r\n    return PolarModel;\r\n}());\r\nexports.PolarModel = PolarModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/polarModel.ts?");

/***/ }),

/***/ "./src/model/scaleModel.ts":
/*!*********************************!*\
  !*** ./src/model/scaleModel.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ScaleModel = exports.ScaleType = void 0;\r\nvar modelHelper_1 = __webpack_require__(/*! ./modelHelper */ \"./src/model/modelHelper.ts\");\r\nvar ScaleType;\r\n(function (ScaleType) {\r\n    ScaleType[ScaleType[\"Key\"] = 0] = \"Key\";\r\n    ScaleType[ScaleType[\"Value\"] = 1] = \"Value\";\r\n})(ScaleType = exports.ScaleType || (exports.ScaleType = {}));\r\nvar ScaleModel = /** @class */ (function () {\r\n    function ScaleModel() {\r\n    }\r\n    ScaleModel.getScaleRangePeek = function (scaleType, chartOrientation, margin, blockSize) {\r\n        if (chartOrientation === 'vertical')\r\n            return scaleType === ScaleType.Key\r\n                ? blockSize.width - margin.left - margin.right\r\n                : blockSize.height - margin.top - margin.bottom;\r\n        return scaleType === ScaleType.Key\r\n            ? blockSize.height - margin.top - margin.bottom\r\n            : blockSize.width - margin.left - margin.right;\r\n    };\r\n    ScaleModel.getScaleKeyDomain = function (allowableKeys) {\r\n        return allowableKeys;\r\n    };\r\n    ScaleModel.getScaleDateValueDomain = function (data, charts, keyAxisPosition, allowableKeys) {\r\n        var minMax = modelHelper_1.ModelHelper.getMinAndMaxOfIntervalData(data, charts);\r\n        var domainPeekMin = minMax[0];\r\n        var domainPeekMax = minMax[1];\r\n        if (keyAxisPosition === 'start')\r\n            return [domainPeekMin, domainPeekMax];\r\n        return [domainPeekMax, domainPeekMin];\r\n    };\r\n    ScaleModel.getScaleLinearValueDomain = function (configDomain, data, configOptions) {\r\n        var domainPeekMin;\r\n        var domainPeekMax;\r\n        if (configDomain.start === -1)\r\n            domainPeekMin = 0;\r\n        else\r\n            domainPeekMin = configDomain.start;\r\n        if (configDomain.end === -1)\r\n            domainPeekMax = this.getScaleMaxValue(configOptions, data);\r\n        else\r\n            domainPeekMax = configDomain.end;\r\n        if (configOptions.axis.keyAxis.position === 'start')\r\n            return [domainPeekMin, domainPeekMax];\r\n        return [domainPeekMax, domainPeekMin];\r\n    };\r\n    ScaleModel.getScaleKeyType = function (charts) {\r\n        if (charts.findIndex(function (chart) { return chart.type === 'bar' || chart.type === 'gantt'; }) === -1)\r\n            return 'point';\r\n        return 'band';\r\n    };\r\n    ScaleModel.getScaleValueType = function (charts) {\r\n        if (charts.findIndex(function (chart) { return chart.type === 'gantt'; }) !== -1)\r\n            return 'datetime';\r\n        return 'linear';\r\n    };\r\n    ScaleModel.getScaleElementsAmount = function (barCharts, isSegmented) {\r\n        if (barCharts.length === 0)\r\n            return 1;\r\n        return isSegmented\r\n            ? barCharts.length\r\n            : modelHelper_1.ModelHelper.getMaxNumberValue(barCharts.map(function (chart) { return chart.data.valueFields.length; }));\r\n    };\r\n    ScaleModel.getScaleMaxValue = function (configOptions, data) {\r\n        var max = 0;\r\n        configOptions.charts.forEach(function (chart) {\r\n            data[chart.data.dataSource].forEach(function (dataRow) {\r\n                var sumInRow = 0;\r\n                chart.data.valueFields.forEach(function (field) {\r\n                    if (configOptions.isSegmented)\r\n                        sumInRow += dataRow[field.name];\r\n                    else if (dataRow[field.name] > sumInRow)\r\n                        sumInRow = dataRow[field.name];\r\n                });\r\n                if (max < sumInRow)\r\n                    max = sumInRow;\r\n            });\r\n        });\r\n        return max;\r\n    };\r\n    return ScaleModel;\r\n}());\r\nexports.ScaleModel = ScaleModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/scaleModel.ts?");

/***/ }),

/***/ "./src/model/twoDimensionalModel.ts":
/*!******************************************!*\
  !*** ./src/model/twoDimensionalModel.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.TwoDimensionalModel = void 0;\r\nvar axisModel_1 = __webpack_require__(/*! ./axisModel */ \"./src/model/axisModel.ts\");\r\nvar chartStyleModel_1 = __webpack_require__(/*! ./chartStyleModel */ \"./src/model/chartStyleModel.ts\");\r\nvar dataManagerModel_1 = __webpack_require__(/*! ./dataManagerModel */ \"./src/model/dataManagerModel.ts\");\r\nvar gridLineModel_1 = __webpack_require__(/*! ./gridLineModel */ \"./src/model/gridLineModel.ts\");\r\nvar legendModel_1 = __webpack_require__(/*! ./legendModel/legendModel */ \"./src/model/legendModel/legendModel.ts\");\r\nvar modelOptions_1 = __webpack_require__(/*! ./modelOptions */ \"./src/model/modelOptions.ts\");\r\nvar scaleModel_1 = __webpack_require__(/*! ./scaleModel */ \"./src/model/scaleModel.ts\");\r\nvar TwoDimensionalModel = /** @class */ (function () {\r\n    function TwoDimensionalModel() {\r\n    }\r\n    TwoDimensionalModel.getOptions = function (config, designerConfig, margin, dataScope, data) {\r\n        var configOptions = config.options;\r\n        return {\r\n            legend: legendModel_1.LegendModel.getLegendModel(config.options.type, config.options.legend.position, config.canvas.size, margin),\r\n            orient: configOptions.orientation,\r\n            isSegmented: configOptions.isSegmented,\r\n            scale: {\r\n                scaleKey: {\r\n                    domain: scaleModel_1.ScaleModel.getScaleKeyDomain(dataScope.allowableKeys),\r\n                    range: {\r\n                        start: 0,\r\n                        end: scaleModel_1.ScaleModel.getScaleRangePeek(scaleModel_1.ScaleType.Key, configOptions.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: scaleModel_1.ScaleModel.getScaleKeyType(configOptions.charts),\r\n                    elementsAmount: scaleModel_1.ScaleModel.getScaleElementsAmount(this.getChartsByType(configOptions.charts, 'bar'), configOptions.isSegmented)\r\n                },\r\n                scaleValue: {\r\n                    domain: scaleModel_1.ScaleModel.getScaleLinearValueDomain(configOptions.axis.valueAxis.domain, data, configOptions),\r\n                    range: {\r\n                        start: 0,\r\n                        end: scaleModel_1.ScaleModel.getScaleRangePeek(scaleModel_1.ScaleType.Value, configOptions.orientation, margin, config.canvas.size)\r\n                    },\r\n                    type: scaleModel_1.ScaleModel.getScaleValueType(configOptions.charts)\r\n                }\r\n            },\r\n            axis: {\r\n                keyAxis: {\r\n                    type: 'key',\r\n                    orient: axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position),\r\n                    translate: {\r\n                        translateX: axisModel_1.AxisModel.getAxisTranslateX(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position, margin, config.canvas.size.width),\r\n                        translateY: axisModel_1.AxisModel.getAxisTranslateY(modelOptions_1.AxisType.Key, configOptions.orientation, configOptions.axis.keyAxis.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'key-axis',\r\n                    ticks: configOptions.axis.keyAxis.ticks,\r\n                    labels: {\r\n                        maxSize: designerConfig.canvas.axisLabel.maxSize.main,\r\n                        positition: axisModel_1.AxisModel.getKeyAxisLabelPosition(margin, config.canvas.size, dataManagerModel_1.DataManagerModel.getDataValuesByKeyField(data, configOptions.charts[0]).length),\r\n                        visible: !TwoDimensionalModel.getChartsEmbeddedLabelsFlag(configOptions.charts, configOptions, data, configOptions.orientation, config.canvas.size, margin, designerConfig.canvas.chartOptions.bar, configOptions.isSegmented)\r\n                    }\r\n                },\r\n                valueAxis: {\r\n                    type: 'value',\r\n                    orient: axisModel_1.AxisModel.getAxisOrient(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position),\r\n                    translate: {\r\n                        translateX: axisModel_1.AxisModel.getAxisTranslateX(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position, margin, config.canvas.size.width),\r\n                        translateY: axisModel_1.AxisModel.getAxisTranslateY(modelOptions_1.AxisType.Value, configOptions.orientation, configOptions.axis.valueAxis.position, margin, config.canvas.size.height)\r\n                    },\r\n                    cssClass: 'value-axis',\r\n                    ticks: configOptions.axis.valueAxis.ticks,\r\n                    labels: {\r\n                        maxSize: designerConfig.canvas.axisLabel.maxSize.main,\r\n                        positition: 'straight',\r\n                        visible: true\r\n                    }\r\n                }\r\n            },\r\n            type: configOptions.type,\r\n            charts: this.getChartsModel(configOptions.charts, designerConfig.chart.style.palette, configOptions.orientation, configOptions.isSegmented),\r\n            additionalElements: this.getAdditionalElements(configOptions, designerConfig)\r\n        };\r\n    };\r\n    TwoDimensionalModel.getChartsEmbeddedLabelsFlag = function (charts, configOptions, data, chartOrientation, blockSize, margin, barOptions, isSegmented) {\r\n        return !isSegmented\r\n            && chartOrientation === 'horizontal'\r\n            && charts.length === this.findChartsWithEmbeddedKeyLabels(charts).length;\r\n    };\r\n    TwoDimensionalModel.getBarSize = function (elementsInGroupAmount, keysAmount, chartOrientation, blockSize, margin, barOptions) {\r\n        var axisSize = axisModel_1.AxisModel.getAxisLength(chartOrientation, margin, blockSize);\r\n        return (axisSize / keysAmount - (elementsInGroupAmount - 1) * barOptions.barDistance - barOptions.groupMinDistance) / elementsInGroupAmount;\r\n    };\r\n    TwoDimensionalModel.getChartsModel = function (charts, chartPalette, chartOrientation, isSegmented) {\r\n        var _this = this;\r\n        var chartsModel = [];\r\n        charts.forEach(function (chart, index) {\r\n            chartsModel.push({\r\n                type: chart.type,\r\n                title: chart.title,\r\n                data: __assign({}, chart.data),\r\n                tooltip: chart.tooltip,\r\n                cssClasses: chartStyleModel_1.ChartStyleModel.getCssClasses(index),\r\n                style: chartStyleModel_1.ChartStyleModel.get2DChartStyle(chartPalette, charts.length, chart.type, _this.getChartsValueFieldsAmount(charts), index, isSegmented),\r\n                embeddedLabels: _this.getEmbeddedLabelType(chart, chartOrientation),\r\n                index: index\r\n            });\r\n        });\r\n        return chartsModel;\r\n    };\r\n    TwoDimensionalModel.findChartsWithEmbeddedKeyLabels = function (charts) {\r\n        var chartsWithEmbeddedLabels = [];\r\n        charts.forEach(function (chart) {\r\n            if (chart.type === 'bar' && chart.embeddedLabels === 'key')\r\n                chartsWithEmbeddedLabels.push(chart);\r\n        });\r\n        return chartsWithEmbeddedLabels;\r\n    };\r\n    TwoDimensionalModel.getEmbeddedLabelType = function (currentChart, chartOrientation) {\r\n        if (chartOrientation === 'horizontal' && currentChart.type === 'bar')\r\n            return currentChart.embeddedLabels;\r\n        return 'none';\r\n    };\r\n    TwoDimensionalModel.getAdditionalElements = function (options, designerConfig) {\r\n        return {\r\n            gridLine: gridLineModel_1.GridLineModel.getGridLineOptions(options.additionalElements.gridLine, designerConfig.additionalElements.gridLine)\r\n        };\r\n    };\r\n    TwoDimensionalModel.getChartsByType = function (charts, type) {\r\n        return charts.filter(function (chart) { return chart.type === type; });\r\n    };\r\n    TwoDimensionalModel.getChartsValueFieldsAmount = function (charts) {\r\n        return charts.map(function (chart) { return chart.data.valueFields.length; });\r\n    };\r\n    return TwoDimensionalModel;\r\n}());\r\nexports.TwoDimensionalModel = TwoDimensionalModel;\r\n\n\n//# sourceURL=webpack://mdt-charts/./src/model/twoDimensionalModel.ts?");

/***/ })

}]);