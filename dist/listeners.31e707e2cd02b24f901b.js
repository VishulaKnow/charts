/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/*!************************************!*\
  !*** ./src/listeners/listeners.ts ***!
  \************************************/
eval("// import engine from '../engine/engine';\r\n// import config from '../config/configOptions';\r\n// import designerConfig from '../designer/designerConfigOptions';\r\n// import { getPreparedData, getUpdatedModel } from '../model/modelOptions';\r\n// import { Config, PolarChart, PolarOptions, TwoDimensionalChart, TwoDimensionalOptions } from '../config/config'\r\n// import { color } from 'd3';\r\n// const data = require('../assets/dataSet.json');\r\n// function randInt(min: number, max: number): number {\r\n//     return Math.round(Math.random() * (max - min) + min);\r\n// }\r\n// function getCopy(obj: any) {\r\n//     const newObj: any = {};\r\n//     if(typeof obj === 'object') {\r\n//         for(let key in obj) {        \r\n//             if(Array.isArray(obj[key])) {\r\n//                 newObj[key] = getCopyOfArr(obj[key]);\r\n//             } else if(typeof obj[key] === 'object') {\r\n//                 newObj[key] = getCopy(obj[key]);\r\n//             } else {\r\n//                 newObj[key] = obj[key];\r\n//             }\r\n//         } \r\n//     } else {\r\n//         return obj;\r\n//     }\r\n//     return newObj;\r\n// }\r\n// function getDataWithRandomValues(data: any, maxRand: number) {\r\n//     config.options.charts.forEach((chart: TwoDimensionalChart | PolarChart) => {\r\n//         data[chart.data.dataSource].forEach((row: any) => {\r\n//             row[chart.data.valueField.name] = randInt(0, maxRand);\r\n//         });\r\n//     });\r\n//     return data;\r\n// }\r\n// function getCopyOfArr(initial: any[]): any[] {\r\n//     const newArr: any[] = [];\r\n//     initial.forEach(d => newArr.push(getCopy(d)));\r\n//     return newArr;\r\n// }\r\n// function getInputValue(selector: string): string {\r\n//     return (document.querySelector(selector) as HTMLInputElement).value;\r\n// }\r\n// function setInputValue(selector: string, value: any): void {\r\n//     (document.querySelector(selector) as HTMLInputElement).value = value.toString();\r\n// }\r\n// function setCheckboxValue(selector: string, value: boolean): void {\r\n//     (document.querySelector(selector) as HTMLInputElement).checked = value;\r\n// }\r\n// function updateFull(): void {\r\n//     dropAxisDomain(config);\r\n//     const model = getUpdatedModel();\r\n//     const preparedData = getPreparedData(model, getCopy(data));\r\n//     engine.updateFullBlock(model, preparedData);\r\n// }\r\n// function dropAxisDomain(config: Config) {\r\n//     if(config.options.type === '2d') {\r\n//         config.options.axis.valueAxis.domain.end = -1;\r\n//         config.options.axis.valueAxis.domain.start = -1;\r\n//     }\r\n// }\r\n// function showControlsForNotation(notationType: '2d' | 'polar'): void {\r\n//     if(notationType === '2d') {\r\n//         (document.querySelector('.block-polar') as HTMLElement).style.display = 'none';\r\n//         (document.querySelector('.block-2d') as HTMLElement).style.display = 'block';\r\n//     }\r\n//     else {\r\n//         (document.querySelector('.block-2d') as HTMLElement).style.display = 'none';\r\n//         (document.querySelector('.block-polar') as HTMLElement).style.display = 'block';\r\n//     }\r\n// }\r\n// function changeConfigOptions(notationType: '2d' | 'polar'): void {\r\n//     if(notationType === '2d') {\r\n//         const options: TwoDimensionalOptions = {\r\n//             type: notationType,\r\n//             charts: [\r\n//                 {\r\n//                     data: config.options.charts[0].data,\r\n//                     legend: config.options.charts[0].legend,\r\n//                     title: config.options.charts[0].title,\r\n//                     tooltip: config.options.charts[0].tooltip,\r\n//                     orientation: getInputValue('#chart-orient') as 'horizontal' | 'vertical',\r\n//                     type: getInputValue('#chart-2d-type') as \"area\" | \"line\" | \"bar\"\r\n//                 }\r\n//             ],\r\n//             axis: {\r\n//                 keyAxis: {\r\n//                     domain: {\r\n//                         start: -1,\r\n//                         end: -1\r\n//                     },\r\n//                     position: getInputValue('#key-axis-orient') as \"start\" | \"end\"\r\n//                 },\r\n//                 valueAxis: {\r\n//                     domain: {\r\n//                         start: -1,\r\n//                         end: -1\r\n//                     },\r\n//                     position: getInputValue('#value-axis-orient') as \"start\" | \"end\"\r\n//                 }\r\n//             },\r\n//             additionalElements: {\r\n//                 gridLine: {\r\n//                     flag: {\r\n//                         value: true,\r\n//                         key: false\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n//         if((options.charts[0].type === 'line' || options.charts[0].type === 'bar') && options.charts.length === 1) {\r\n//             options.charts.push(getCopy(options.charts[0]));\r\n//             options.charts[1].data.dataSource = options.charts[0].data.dataSource + '2';\r\n//         } else if((options.charts[0].type === 'line' || options.charts[0].type === 'bar') && options.charts.length === 2) {\r\n//             options.charts[1] = getCopy(options.charts[0]);\r\n//             options.charts[1].data.dataSource = options.charts[0].data.dataSource + '2';\r\n//         }\r\n//         config.options = options;\r\n//     } else {\r\n//         const options: PolarOptions = {\r\n//             type: notationType,\r\n//             charts: [\r\n//                 {\r\n//                     data: config.options.charts[0].data,\r\n//                     legend: config.options.charts[0].legend,\r\n//                     title: config.options.charts[0].title,\r\n//                     tooltip: config.options.charts[0].tooltip,\r\n//                     type: 'donut',\r\n//                     appearanceOptions: {\r\n//                         innerRadius: parseFloat(getInputValue('#inner-radius')) || 0,\r\n//                         padAngle: parseFloat(getInputValue('#pad-angle')) || 0\r\n//                     }\r\n//                 }\r\n//             ]\r\n//         }\r\n//         config.options = options;\r\n//     }\r\n//     updateFull();\r\n// }\r\n// function change2DChartConfig(chartType: 'bar' | 'line' | 'area'): void {\r\n//     if(chartType === 'area') {\r\n//         if(config.options.charts.length !== 1)\r\n//             config.options.charts.splice(1, config.options.charts.length - 1);\r\n//         config.options.charts[0].type = chartType;\r\n//     } else if((chartType === 'bar' || chartType === 'line') && config.options.charts.length === 1) {\r\n//         config.options.charts.push(getCopy(config.options.charts[0]));\r\n//         config.options.charts.forEach((chart: any) => chart.type = chartType);\r\n//         config.options.charts[1].data.dataSource = config.options.charts[0].data.dataSource + '2';\r\n//     } else if((chartType === 'bar' || chartType === 'line') && config.options.charts.length === 2) {\r\n//         // config.options.charts[1] = getCopy(config.options.charts[0]);\r\n//         config.options.charts.forEach((chart: any) => chart.type = chartType);\r\n//         config.options.charts[1].data.dataSource = config.options.charts[0].data.dataSource + '2';\r\n//     }\r\n// }\r\n// function setMainListeners(): void {\r\n//     document.querySelector('#notation').addEventListener('change', function() {\r\n//         showControlsForNotation(this.value);\r\n//         changeConfigOptions(this.value);\r\n//         setControlsValues();\r\n//     });\r\n//     document.querySelector('#block-width').addEventListener('input', function(e: KeyboardEvent) {\r\n//         config.canvas.size.width = parseFloat(getInputValue('#block-width')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#block-height').addEventListener('input', function(e: KeyboardEvent) {\r\n//         config.canvas.size.height = parseFloat(getInputValue('#block-height')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#wrapper-border').addEventListener('change', function() {\r\n//         if(this.checked)\r\n//             config.canvas.class = 'svg-chart outline';\r\n//         else \r\n//             config.canvas.class = 'svg-chart';\r\n//         updateFull();\r\n//     });\r\n// }\r\n// function setDesignerListeners(): void {\r\n//     document.querySelector('#axis-label-width').addEventListener('input', function() {\r\n//         designerConfig.canvas.axisLabel.maxSize.main = parseFloat(getInputValue('#axis-label-width'));\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#chart-block-margin-top').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartBlockMargin.top = parseFloat(getInputValue('#chart-block-margin-top')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#chart-block-margin-bottom').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartBlockMargin.bottom = parseFloat(getInputValue('#chart-block-margin-bottom')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#chart-block-margin-left').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartBlockMargin.left = parseFloat(getInputValue('#chart-block-margin-left')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#chart-block-margin-right').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartBlockMargin.right = parseFloat(getInputValue('#chart-block-margin-right')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#bar-distance').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartOptions.bar.barDistance = parseFloat(getInputValue('#bar-distance')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#bar-group-distance').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartOptions.bar.groupDistance = parseFloat(getInputValue('#bar-group-distance'));        \r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#min-bar-size').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartOptions.bar.minBarWidth = parseFloat(getInputValue('#min-bar-size')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#min-donut-part-size').addEventListener('input', function() {\r\n//         designerConfig.canvas.chartOptions.donut.minPartSize = parseFloat(getInputValue('#min-donut-part-size')) || 0;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('.btn-base-color').addEventListener('click', function() {\r\n//         designerConfig.chart.style.palette[0] = color(getInputValue('#base-color'));\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#designer-key-grid').addEventListener('change', function() {\r\n//         designerConfig.additionalElements.gridLine.flag.key = this.checked;\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#designer-value-grid').addEventListener('change', function() {\r\n//         designerConfig.additionalElements.gridLine.flag.value = this.checked;\r\n//         updateFull();\r\n//     });\r\n// }\r\n// function setCommonListeners(): void {\r\n//     document.querySelector('#data-size').addEventListener('change', function() {\r\n//         config.options.charts.forEach((chart: TwoDimensionalChart | PolarChart, index: number) => {\r\n//             chart.data.dataSource = this.value === 'normal' \r\n//                 ? 'dataSet' + (index === 0 ? '' : `${index + 1}`)\r\n//                 : 'dataSet_large' + (index === 0 ? '' : `${index + 1}`);\r\n//         });\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('#legend').addEventListener('change', function() {\r\n//         config.options.charts.forEach((chart: TwoDimensionalChart | PolarChart) => {\r\n//             chart.legend.position = this.value;\r\n//         });\r\n//         updateFull();\r\n//     });\r\n//     document.querySelector('.btn-random').addEventListener('click', function() {\r\n//         const max = parseInt(getInputValue('#max-random-value')) || 120;\r\n//         const copy = getCopy(data);\r\n//         const newData = getDataWithRandomValues(copy, max);\r\n//         if(config.options.type === '2d') {\r\n//             config.options.axis.valueAxis.domain.start = -1;\r\n//             config.options.axis.valueAxis.domain.end = max;\r\n//         }\r\n//         const model = getUpdatedModel(newData);\r\n//         const preparedData = getPreparedData(model, newData);\r\n//         engine.updateFullBlock(model, preparedData);\r\n//     });\r\n//     document.querySelector('#max-random-value').addEventListener('keydown', function(e: KeyboardEvent) {\r\n//         if(e.code === 'Enter') {\r\n//             const max = parseInt(getInputValue('#max-random-value')) || 120;\r\n//             const copy = getCopy(data);\r\n//             const newData = getDataWithRandomValues(copy, max);\r\n//             if(config.options.type === '2d') {\r\n//                 config.options.axis.valueAxis.domain.start = -1;\r\n//                 config.options.axis.valueAxis.domain.end = max;\r\n//             }\r\n//             const model = getUpdatedModel(newData);\r\n//             const preparedData = getPreparedData(model, newData);\r\n//             engine.updateFullBlock(model, preparedData);\r\n//         }\r\n//     });\r\n// }\r\n// function set2DListeners(): void {\r\n//     document.querySelector('#chart-2d-type').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             change2DChartConfig(this.value);\r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('#chart-orient').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             config.options.charts.forEach(chart => {\r\n//                 chart.orientation = this.value; \r\n//             }); \r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('#key-axis-orient').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             config.options.axis.keyAxis.position = this.value;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('#value-axis-orient').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             config.options.axis.valueAxis.position = this.value;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('.btn-domain').addEventListener('click', function() {\r\n//         if(config.options.type === '2d') {\r\n//             const start = getInputValue('#domain-start');\r\n//             const end = getInputValue('#domain-end');\r\n//             config.options.axis.valueAxis.domain.start = parseInt(start) || -1;\r\n//             config.options.axis.valueAxis.domain.end = parseInt(end) || -1;\r\n//             engine.updateValueAxis(getUpdatedModel(), getCopy(data));\r\n//         }\r\n//     });\r\n//     document.querySelector('#domain-start').addEventListener('keydown', function(e: KeyboardEvent) {\r\n//         if(e.code === 'Enter') {\r\n//             if(config.options.type === '2d') {\r\n//                 const start = getInputValue('#domain-start');\r\n//                 const end = getInputValue('#domain-end');\r\n//                 config.options.axis.valueAxis.domain.start = parseInt(start) || -1;\r\n//                 config.options.axis.valueAxis.domain.end = parseInt(end) || -1;\r\n//                 engine.updateValueAxis(getUpdatedModel(), getCopy(data));\r\n//             }\r\n//         }\r\n//     });\r\n//     document.querySelector('#domain-end').addEventListener('keydown', function(e: KeyboardEvent) {\r\n//         if(e.code === 'Enter') {\r\n//             if(config.options.type === '2d') {\r\n//                 const start = getInputValue('#domain-start');\r\n//                 const end = getInputValue('#domain-end');\r\n//                 config.options.axis.valueAxis.domain.start = parseInt(start) || -1;\r\n//                 config.options.axis.valueAxis.domain.end = parseInt(end) || -1;\r\n//                 engine.updateValueAxis(getUpdatedModel(), getCopy(data));\r\n//             }\r\n//         }\r\n//     });\r\n//     document.querySelector('#config-key-grid').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             config.options.additionalElements.gridLine.flag.key = this.checked;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('#config-value-grid').addEventListener('change', function() {\r\n//         if(config.options.type === '2d') {\r\n//             config.options.additionalElements.gridLine.flag.value = this.checked;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n// }\r\n// function setPolarListeners(): void {\r\n//     document.querySelector('#inner-radius').addEventListener('input', function() {\r\n//         if(config.options.type === 'polar') {\r\n//             const innerRadius = getInputValue('#inner-radius');\r\n//             config.options.charts[0].appearanceOptions.innerRadius = parseInt(innerRadius) || 0;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n//     document.querySelector('#pad-angle').addEventListener('input', function() {\r\n//         if(config.options.type === 'polar') {\r\n//             const padAngle = getInputValue('#pad-angle');\r\n//             config.options.charts[0].appearanceOptions.padAngle = parseFloat(padAngle) || 0;\r\n//             updateFull();\r\n//         }\r\n//     });\r\n// }\r\n// function setControlsValues(): void {\r\n//     setInputValue('#notation', config.options.type);\r\n//     setInputValue('#block-width', config.canvas.size.width);\r\n//     setInputValue('#block-height', config.canvas.size.height);\r\n//     setCheckboxValue('#wrapper-border', config.canvas.class === 'svg-chart outline');\r\n//     setInputValue('#legend', config.options.charts[0].legend.position);\r\n//     setInputValue('#data-size', config.options.charts[0].data.dataSource.includes('large') ? 'large' : 'normal');\r\n//     setInputValue('#axis-label-width', designerConfig.canvas.axisLabel.maxSize.main);\r\n//     setInputValue('#chart-block-margin-top', designerConfig.canvas.chartBlockMargin.top);\r\n//     setInputValue('#chart-block-margin-bottom', designerConfig.canvas.chartBlockMargin.bottom);\r\n//     setInputValue('#chart-block-margin-left', designerConfig.canvas.chartBlockMargin.left);\r\n//     setInputValue('#chart-block-margin-right', designerConfig.canvas.chartBlockMargin.right);\r\n//     setInputValue('#bar-distance', designerConfig.canvas.chartOptions.bar.barDistance);\r\n//     setInputValue('#bar-group-distance', designerConfig.canvas.chartOptions.bar.groupDistance);\r\n//     setInputValue('#min-bar-size', designerConfig.canvas.chartOptions.bar.minBarWidth);\r\n//     setInputValue('#min-donut-part-size', designerConfig.canvas.chartOptions.donut.minPartSize);\r\n//     setInputValue('#base-color', designerConfig.chart.style.palette[0].hex());\r\n//     setCheckboxValue('#designer-key-grid', designerConfig.additionalElements.gridLine.flag.key);\r\n//     setCheckboxValue('#designer-value-grid', designerConfig.additionalElements.gridLine.flag.value);\r\n//     if(config.options.type === '2d') {\r\n//         setInputValue('#chart-2d-type', config.options.charts[0].type);\r\n//         setInputValue('#chart-orient', config.options.charts[0].orientation);\r\n//         setInputValue('#key-axis-orient', config.options.axis.keyAxis.position);\r\n//         setInputValue('#value-axis-orient', config.options.axis.valueAxis.position);\r\n//         setCheckboxValue('#config-key-grid', config.options.additionalElements.gridLine.flag.key);\r\n//         setCheckboxValue('#config-value-grid', config.options.additionalElements.gridLine.flag.value);\r\n//     } else {\r\n//         setInputValue('#chart-polar-type', config.options.charts[0].type);\r\n//         setInputValue('#inner-radius', config.options.charts[0].appearanceOptions.innerRadius.toString());\r\n//         setInputValue('#pad-angle', config.options.charts[0].appearanceOptions.padAngle.toString());\r\n//     }\r\n// }\r\n// setControlsValues();\r\n// showControlsForNotation(config.options.type);\r\n// setMainListeners();\r\n// setDesignerListeners();\r\n// setCommonListeners();\r\n// set2DListeners();\r\n// setPolarListeners();\r\n\n\n//# sourceURL=webpack://packd3ts/./src/listeners/listeners.ts?");
/******/ })()
;